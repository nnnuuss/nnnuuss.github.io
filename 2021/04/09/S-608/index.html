<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="xv6: a simple, Unix-like teaching operating systemRuss Cox      Frans Kaashoek      Robert Morris August 31, 2020  Contents Foreword and acknowledgmentsThis is a draft text intended for a class on ope">
<meta property="og:type" content="article">
<meta property="og:title" content="S.608">
<meta property="og:url" content="http://example.com/2021/04/09/S-608/index.html">
<meta property="og:site_name" content="Nnnuus&#39;s World">
<meta property="og:description" content="xv6: a simple, Unix-like teaching operating systemRuss Cox      Frans Kaashoek      Robert Morris August 31, 2020  Contents Foreword and acknowledgmentsThis is a draft text intended for a class on ope">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image001.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image003.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image005.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image006.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image007.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image009.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image010.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image012.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image013.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image014.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image015.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image016.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image021.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image022.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image023.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image024.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image025.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image026.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image031.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image032.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image033.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image034.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image032.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image035.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image036.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image037.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image042.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image044.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image045.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image049.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image001.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image051.jpg">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image056.gif">
<meta property="og:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image058.gif">
<meta property="article:published_time" content="2021-04-09T02:19:55.000Z">
<meta property="article:modified_time" content="2021-04-09T09:12:33.527Z">
<meta property="article:author" content="Nnnuus">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image001.gif">

<link rel="canonical" href="http://example.com/2021/04/09/S-608/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>S.608 | Nnnuus's World</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Nnnuus's World</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/09/S-608/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2021/03/13/nZa6FtkdxThVQoS.jpg">
      <meta itemprop="name" content="Nnnuus">
      <meta itemprop="description" content="比过程更重要的是结果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nnnuus's World">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          S.608
        </h1>

        <div class="post-meta">

		
		<i class="fa fa-thumb-tack"></i>
		<font color=7D26CD>置顶</font>
		<span class="post-meta-divider">|</span>
		
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-09 10:19:55 / 修改时间：17:12:33" itemprop="dateCreated datePublished" datetime="2021-04-09T10:19:55+08:00">2021-04-09</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="xv6-a-simple-Unix-like-teaching-operating-system"><a href="#xv6-a-simple-Unix-like-teaching-operating-system" class="headerlink" title="xv6: a simple, Unix-like teaching operating system"></a><strong>xv6: a simple, Unix-like teaching operating system</strong></h1><p>Russ Cox      Frans Kaashoek      Robert Morris August 31, 2020 </p>
<p><strong>Contents</strong></p>
<h2 id="Foreword-and-acknowledgments"><a href="#Foreword-and-acknowledgments" class="headerlink" title="Foreword and acknowledgments"></a><strong>Foreword and acknowledgments</strong></h2><p>This is a draft text intended for a class on operating systems. It explains the main concepts of operating systems by studying an example kernel, named xv6. xv6 is modeled on Dennis Ritchie’s and Ken Thompson’s Unix Version 6 (v6) [14]. xv6 loosely follows the structure and style of v6, but is implemented in ANSI C [6] for a multi-core RISC-V [12].</p>
<p>This text should be read along with the source code for xv6, an approach inspired by John Li- ons’ Commentary on UNIX 6th Edition [9]. See <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081">https://pdos.csail.mit.edu/6.S081</a> for pointers to on-line resources for v6 and xv6, including several lab assignments using xv6.</p>
<p>We have used this text in 6.828 and 6.S081, the operating systems classes at MIT. We thank the faculty, teaching assistants, and students of those classes who have all directly or indirectly con- tributed to xv6. In particular, we would like to thank Adam Belay, Austin Clements, and Nickolai Zeldovich. Finally, we would like to thank people who emailed us bugs in the text or sugges- tions for improvements: Abutalib Aghayev, Sebastian Boehm, Anton Burtsev, Raphael Carvalho, Tej Chajed, Rasit Eskicioglu, Color Fuzzy, Giuseppe, Tao Guo, Naoki Hayama, Robert Hilder- man, Wolfgang Keller, Austin Liew, Pavan Maddamsetti, Jacek Masiulaniec, Michael McConville, m3hm00d, miguelgvieira, Mark Morrissey, Harry Pan, Askar Safin, Salman Shah, Adeodato Simó, Ruslan Savchenko, Pawel Szczurko, Warren Toomey, tyfkda, tzerbib, Xi Wang, and Zou Chang Wei.</p>
<p>If you spot errors or have suggestions for improvement, please send email to Frans Kaashoek and Robert Morris (kaashoek,<a href="mailto:&#114;&#x74;&#x6d;&#x40;&#x63;&#x73;&#x61;&#105;&#x6c;&#46;&#109;&#105;&#116;&#x2e;&#x65;&#100;&#x75;">&#114;&#x74;&#x6d;&#x40;&#x63;&#x73;&#x61;&#105;&#x6c;&#46;&#109;&#105;&#116;&#x2e;&#x65;&#100;&#x75;</a>).</p>
<h1 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="**Chapter 1 **  Operating system interfaces"></a>**Chapter 1 **  Operating system interfaces</h1><p>The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports. An operating system manages and abstracts the low-level hardware, so that, for example, a word processor need not concern itself with which type of disk hardware is being used. An operating system shares the hardware among multiple programs so that they run (or appear to run) at the same time. Finally, operating systems provide controlled ways for programs to interact, so that they can share data or work together.</p>
<p>An operating system provides services to user programs through an interface. Designing a good interface turns out to be difficult. On the one hand, we would like the interface to be simple and narrow because that makes it easier to get the implementation right. On the other hand, we may be tempted to offer many sophisticated features to applications. The trick in resolving this tension is to design interfaces that rely on a few mechanisms that can be combined to provide much generality. This book uses a single operating system as a concrete example to illustrate operating system concepts. That operating system, xv6, provides the basic interfaces introduced by Ken Thompson and Dennis Ritchie’s Unix operating system [14], as well as mimicking Unix’s internal design. Unix provides a narrow interface whose mechanisms combine well, offering a surprising degree of generality. This interface has been so successful that modern operating systems—BSD, Linux, Mac OS X, Solaris, and even, to a lesser extent, Microsoft Windows—have Unix-like interfaces.</p>
<p>Understanding xv6 is a good start toward understanding any of these systems and many others.</p>
<p>As Figure 1.1 shows, xv6 takes the traditional form of a <em>kernel</em>, a special program that provides services to running programs. Each running program, called a <em>process</em>, has memory containing instructions, data, and a stack. The instructions implement the program’s computation. The data are the variables on which the computation acts. The stack organizes the program’s procedure calls. A given computer typically has many processes but only a single kernel.</p>
<p>When a process needs to invoke a kernel service, it invokes a <em>system call</em>, one of the calls in the operating system’s interface. The system call enters the kernel; the kernel performs the service and returns. Thus a process alternates between executing in <em>user space</em> and <em>kernel space</em>.</p>
<p>The kernel uses the hardware protection mechanisms provided by a CPU1 to ensure that each</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image001.gif" alt="img"></td>
</tr>
</tbody></table>
<p>1This text generally refers to the hardware element that executes a computation with the term <em>CPU</em>, an acronym for central processing unit. Other documentation (e.g., the RISC-V specification) also uses the words processor, core, and hart instead of CPU.</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image003.gif" alt="img"></p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image005.gif" alt="img">Figure 1.1: A kernel and two user processes.</p>
<p>process executing in user space can access only its own memory. The kernel executes with the hardware privileges required to implement these protections; user programs execute without those privileges. When a user program invokes a system call, the hardware raises the privilege level and starts executing a pre-arranged function in the kernel.</p>
<p>The collection of system calls that a kernel provides is the interface that user programs see. The xv6 kernel provides a subset of the services and system calls that Unix kernels traditionally offer. Figure 1.2 lists all of xv6’s system calls.</p>
<p>The rest of this chapter outlines xv6’s services—processes, memory, file descriptors, pipes, and a file system—and illustrates them with code snippets and discussions of how the <em>shell</em>, Unix’s command-line user interface, uses them. The shell’s use of system calls illustrates how carefully they have been designed.</p>
<p>The shell is an ordinary program that reads commands from the user and executes them. The fact that the shell is a user program, and not part of the kernel, illustrates the power of the system call interface: there is nothing special about the shell. It also means that the shell is easy to replace; as a result, modern Unix systems have a variety of shells to choose from, each with its own user interface and scripting features. The xv6 shell is a simple implementation of the essence of the Unix Bourne shell. Its implementation can be found at <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L1">(user/sh.c:1)</a>.</p>
<h2 id="1-1-Processes-and-memory"><a href="#1-1-Processes-and-memory" class="headerlink" title="1.1     Processes and memory"></a><strong>1.1</strong>     <strong>Processes and memory</strong></h2><p>An xv6 process consists of user-space memory (instructions, data, and stack) and per-process state private to the kernel. Xv6 <em>time-share</em>s processes: it transparently switches the available CPUs among the set of processes waiting to execute. When a process is not executing, xv6 saves its CPU registers, restoring them when it next runs the process. The kernel associates a process identifier, or PID, with each process.</p>
<p>A process may create a new process using the fork system call. Fork creates a new process, called the <em>child process</em>, with exactly the same memory contents as the calling process, called the <em>parent process</em>. Fork returns in both the parent and the child. In the parent, fork returns the child’s PID; in the child, fork returns zero. For example, consider the following program fragment written in the C programming language [6]:</p>
<p>int pid = fork(); if(pid &gt; 0){</p>
<p>printf(“parent: child=%d\n”, pid);</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image006.gif" alt="img"></h4><p>System call                  Description</p>
<p>int fork()                     Create a process, return child’s PID.</p>
<p>int exit(int status)              Terminate the current process; status reported to wait(). No return. int wait(int *status) Wait for a child to exit; exit status in *status; returns child PID. int kill(int pid)   Terminate process PID. Returns 0, or -1 for error.</p>
<p>int getpid()                   Return the current process’s PID.</p>
<p>int sleep(int n)                Pause for n clock ticks.</p>
<p>int exec(char *file, char *argv[])  Load a file and execute it with arguments; only returns if error. char *sbrk(int n)    Grow process’s memory by n bytes. Returns start of new memory. int open(char *file, int flags)                       Open a file; flags indicate read/write; returns an fd (file descriptor). int write(int fd, char *buf, int n) Write n bytes from buf to file descriptor fd; returns n.</p>
<p>int read(int fd, char *buf, int n)   Read n bytes into buf; returns number read; or 0 if end of file. int close(int fd)  Release open file fd.</p>
<p>int dup(int fd)                 Return a new file descriptor referring to the same file as fd.</p>
<p>int pipe(int p[])                Create a pipe, put read/write file descriptors in p[0] and p[1].</p>
<p>int chdir(char *dir)             Change the current directory.</p>
<p>int mkdir(char *dir)            Create a new directory. int mknod(char *file, int, int)                      Create a device file.</p>
<p>int fstat(int fd, struct stat *st)     Place info about an open file into *st. int stat(char *file, struct stat *st)                 Place info about a named file into *st.</p>
<p>int link(char *file1, char *file2)   Create another name (file2) for the file file1. int unlink(char *file)                            Remove a file.</p>
<p>Figure 1.2: Xv6 system calls. If not otherwise stated, these calls return 0 for no error, and -1 if there’s an error.</p>
<p>pid = wait((int *) 0); printf(“child %d is done\n”, pid);</p>
<p>} else if(pid == 0){ printf(“child: exiting\n”); exit(0);</p>
<p>} else {</p>
<p>printf(“fork error\n”);</p>
<p>}</p>
<p>The exit system call causes the calling process to stop executing and to release resources such as memory and open files. Exit takes an integer status argument, conventionally 0 to indicate success and 1 to indicate failure. The wait system call returns the PID of an exited (or killed) child of the current process and copies the exit status of the child to the address passed to wait; if none of the caller’s children has exited, wait waits for one to do so. If the caller has no children, wait immediately returns -1. If the parent doesn’t care about the exit status of a child, it can pass a 0 address to wait.</p>
<p>In the example, the output lines</p>
<p>parent: child=1234 child: exiting</p>
<p>might come out in either order, depending on whether the parent or child gets to its printf call first. After the child exits, the parent’s wait returns, causing the parent to print</p>
<p>parent: child 1234 is done</p>
<p>Although the child has the same memory contents as the parent initially, the parent and child are executing with different memory and different registers: changing a variable in one does not affect the other. For example, when the return value of wait is stored into pid in the parent process, it doesn’t change the variable pid in the child. The value of pid in the child will still be zero.</p>
<p>The exec system call replaces the calling process’s memory with a new memory image loaded from a file stored in the file system. The file must have a particular format, which specifies which part of the file holds instructions, which part is data, at which instruction to start, etc. xv6 uses the ELF format, which Chapter 3 discusses in more detail. When exec succeeds, it does not return to the calling program; instead, the instructions loaded from the file start executing at the entry point declared in the ELF header. Exec takes two arguments: the name of the file containing the executable and an array of string arguments. For example:</p>
<p>char *argv[3];</p>
<p>argv[0] = “echo”;</p>
<p>argv[1] = “hello”; argv[2] = 0; exec(“/bin/echo”, argv); printf(“exec error\n”);</p>
<p>This fragment replaces the calling program with an instance of the program /bin/echo running with the argument list echo hello. Most programs ignore the first element of the argument array, which is conventionally the name of the program.</p>
<p>The xv6 shell uses the above calls to run programs on behalf of users. The main structure of the shell is simple; see main <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L145">(user/sh.c:145)</a>. The main loop reads a line of input from the user with getcmd. Then it calls fork, which creates a copy of the shell process. The parent calls wait, while the child runs the command. For example, if the user had typed “echo hello” to the shell, runcmd would have been called with “echo hello” as the argument. runcmd <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L58">(user/sh.c:58) </a>runs the actual command. For “echo hello”, it would call exec <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L78">(user/sh.c:78)</a>. If exec succeeds then the child will execute instructions from echo instead of runcmd. At some point echo will call exit, which will cause the parent to return from wait in main <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L145">(user/sh.c:145)</a>.</p>
<p>You might wonder why fork and exec are not combined in a single call; we will see later that the shell exploits the separation in its implementation of I/O redirection. To avoid the wastefulness of creating a duplicate process and then immediately replacing it (with exec), operating kernels optimize the implementation of fork for this use case by using virtual memory techniques such as copy-on-write (see Section 4.6).</p>
<p>Xv6 allocates most user-space memory implicitly: fork allocates the memory required for the child’s copy of the parent’s memory, and exec allocates enough memory to hold the executable</p>
<p>file. A process that needs more memory at run-time (perhaps for malloc) can call sbrk(n) to grow its data memory by n bytes; sbrk returns the location of the new memory.</p>
<h2 id="1-2-I-O-and-File-descriptors"><a href="#1-2-I-O-and-File-descriptors" class="headerlink" title="1.2     I/O and File descriptors"></a><strong>1.2</strong>     <strong>I/O and File descriptors</strong></h2><p>A <em>file descriptor</em> is a small integer representing a kernel-managed object that a process may read from or write to. A process may obtain a file descriptor by opening a file, directory, or device,  or by creating a pipe, or by duplicating an existing descriptor. For simplicity we’ll often refer  to the object a file descriptor refers to as a “file”; the file descriptor interface abstracts away the differences between files, pipes, and devices, making them all look like streams of bytes. We’ll refer to input and output as <em>I/O</em>.</p>
<p>Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so that every process has a private space of file descriptors starting at zero. By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). As we will see, the shell exploits the convention to implement I/O redirection and pipelines. The shell ensures that it always has three file descriptors open <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L151">(user/sh.c:151)</a>, which are by default file descriptors for the console.</p>
<p>The read and write system calls read bytes from and write bytes to open files named by file descriptors. The call read(fd, buf, n) reads at most n bytes from the file descriptor fd, copies them into buf, and returns the number of bytes read. Each file descriptor that refers to a file has an offset associated with it. Read reads data from the current file offset and then advances that offset by the number of bytes read: a subsequent read will return the bytes following the ones returned by the first read. When there are no more bytes to read, read returns zero to indicate the end of the file.</p>
<p>The call write(fd, buf, n) writes n bytes from buf to the file descriptor fd and returns the number of bytes written. Fewer than n bytes are written only when an error occurs. Like read, write writes data at the current file offset and then advances that offset by the number of bytes written: each write picks up where the previous one left off.</p>
<p>The following program fragment (which forms the essence of the program cat) copies data from its standard input to its standard output. If an error occurs, it writes a message to the standard error.</p>
<p>char buf[512]; int n;</p>
<p>for(;;){</p>
<p>n = read(0, buf, sizeof buf); if(n == 0)</p>
<p>break; if(n &lt; 0){</p>
<p>fprintf(2, “read error\n”); exit(1);</p>
<p>}</p>
<p>if(write(1, buf, n) != n){ fprintf(2, “write error\n”); exit(1);</p>
<p>}</p>
<p>}</p>
<p>The important thing to note in the code fragment is that cat doesn’t know whether it is reading from a file, console, or a pipe. Similarly cat doesn’t know whether it is printing to a console, a file, or whatever. The use of file descriptors and the convention that file descriptor 0 is input and file descriptor 1 is output allows a simple implementation of cat.</p>
<p>The close system call releases a file descriptor, making it free for reuse by a future open, pipe, or dup system call (see below). A newly allocated file descriptor is always the lowest- numbered unused descriptor of the current process.</p>
<p>File descriptors and fork interact to make I/O redirection easy to implement. Fork copies the parent’s file descriptor table along with its memory, so that the child starts with exactly the same open files as the parent. The system call exec replaces the calling process’s memory but preserves its file table. This behavior allows the shell to implement <em>I/O redirection</em> by forking, re- opening chosen file descriptors in the child, and then calling exec to run the new program. Here is a simplified version of the code a shell runs for the command cat &lt; input.txt:</p>
<p>char *argv[2];</p>
<p>argv[0] = “cat”; argv[1] = 0; if(fork() == 0) {</p>
<p>close(0);</p>
<p>open(“input.txt”, O_RDONLY); exec(“cat”, argv);</p>
<p>}</p>
<p>After the child closes file descriptor 0, open is guaranteed to use that file descriptor for the newly opened input.txt: 0 will be the smallest available file descriptor. Cat then executes with file descriptor 0 (standard input) referring to input.txt. The parent process’s file descriptors are not changed by this sequence, since it modifies only the child’s descriptors.</p>
<p>The code for I/O redirection in the xv6 shell works in exactly this way <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L82">(user/sh.c:82)</a>. Recall that at this point in the code the shell has already forked the child shell and that runcmd will call exec to load the new program.</p>
<p>The second argument to open consists of a set of flags, expressed as bits, that control what open does. The possible values are defined in the file control (fcntl) header <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fcntl.h#L1-L5">(kernel/fcntl.h:1-5)</a>: O_RDONLY, O_WRONLY, O_RDWR, O_CREATE, and O_TRUNC, which instruct open to open the file for reading, or for writing, or for both reading and writing, to create the file if it doesn’t exist, and to truncate the file to zero length.</p>
<p>Now it should be clear why it is helpful that fork and exec are separate calls: between the two, the shell has a chance to redirect the child’s I/O without disturbing the I/O setup of the main shell. One could instead imagine a hypothetical combined forkexec system call, but the options</p>
<p>for doing I/O redirection with such a call seem awkward. The shell could modify its own I/O setup before calling forkexec (and then un-do those modifications); or forkexec could take instructions for I/O redirection as arguments; or (least attractively) every program like cat could be taught to do its own I/O redirection.</p>
<p>Although fork copies the file descriptor table, each underlying file offset is shared between parent and child. Consider this example:</p>
<p>if(fork() == 0) {</p>
<p>write(1, “hello “, 6); exit(0);</p>
<p>} else { wait(0);</p>
<p>write(1, “world\n”, 6);</p>
<p>}</p>
<p>At the end of this fragment, the file attached to file descriptor 1 will contain the data hello world. The write in the parent (which, thanks to wait, runs only after the child is done) picks up where the child’s write left off. This behavior helps produce sequential output from sequences of shell commands, like (echo hello; echo world) &gt;output.txt.</p>
<p>The dup system call duplicates an existing file descriptor, returning a new one that refers to the same underlying I/O object. Both file descriptors share an offset, just as the file descriptors duplicated by fork do. This is another way to write hello world into a file:</p>
<p>fd = dup(1);</p>
<p>write(1, “hello “, 6);</p>
<p>write(fd, “world\n”, 6);</p>
<p>Two file descriptors share an offset if they were derived from the same original file descriptor by a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if they resulted from open calls for the same file. Dup allows shells to implement commands like this: ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1. The 2&gt;&amp;1 tells the shell to give the command a file descriptor 2 that is a duplicate of descriptor 1. Both the name of the existing file and the error message for the non-existing file will show up in the file tmp1. The xv6 shell doesn’t support I/O redirection for the error file descriptor, but now you know how to implement it.</p>
<p>File descriptors are a powerful abstraction, because they hide the details of what they are con- nected to: a process writing to file descriptor 1 may be writing to a file, to a device like the console, or to a pipe.</p>
<h2 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3     Pipes"></a><strong>1.3</strong>     <strong>Pipes</strong></h2><p>A <em>pipe</em> is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. Pipes provide a way for processes to communicate.</p>
<p>The following example code runs the program wc with standard input connected to the read end of a pipe.</p>
<p>int p[2];</p>
<p>char *argv[2];</p>
<p>argv[0] = “wc”; argv[1] = 0;</p>
<p>pipe(p); if(fork() == 0) {</p>
<p>close(0); dup(p[0]);</p>
<p>close(p[0]);</p>
<p>close(p[1]); exec(“/bin/wc”, argv);</p>
<p>} else { close(p[0]);</p>
<p>write(p[1], “hello world\n”, 12); close(p[1]);</p>
<p>}</p>
<p>The program calls pipe, which creates a new pipe and records the read and write file descriptors in the array p. After fork, both parent and child have file descriptors referring to the pipe. The child calls close and dup to make file descriptor zero refer to the read end of the pipe, closes the file descriptors in p, and calls exec to run wc. When wc reads from its standard input, it reads from the pipe. The parent closes the read side of the pipe, writes to the pipe, and then closes the write side.</p>
<p>If no data is available, a read on a pipe waits for either data to be written or for all file descrip- tors referring to the write end to be closed; in the latter case, read will return 0, just as if the end of a data file had been reached. The fact that read blocks until it is impossible for new data to arrive is one reason that it’s important for the child to close the write end of the pipe before executing wc above: if one of wc ’s file descriptors referred to the write end of the pipe, wc would never see end-of-file.</p>
<p>The xv6 shell implements pipelines such as grep fork sh.c | wc -l in a manner similar to the above code <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L100">(user/sh.c:100)</a>. The child process creates a pipe to connect the left end of the pipeline with the right end. Then it calls fork and runcmd for the left end of the pipeline and fork and runcmd for the right end, and waits for both to finish. The right end of the pipeline may be a command that itself includes a pipe (e.g., a | b | c), which itself forks two new child processes (one for b and one for c). Thus, the shell may create a tree of processes. The leaves of this tree are commands and the interior nodes are processes that wait until the left and right children complete.</p>
<p>In principle, one could have the interior nodes run the left end of a pipeline, but doing so correctly would complicate the implementation. Consider making just the following modifica- tion: change sh.c to not fork for p-&gt;left and run runcmd(p-&gt;left) in the interior pro- cess. Then, for example, echo hi | wc won’t produce output, because when echo hi exits in runcmd, the interior process exits and never calls fork to run the right end of the pipe. This</p>
<p>incorrect behavior could be fixed by not calling exit in runcmd for interior processes, but this fix complicates the code: now runcmd needs to know if it a interior process or not. Complications also arise when not forking for runcmd(p-&gt;right). For example, with just that modification, sleep 10 | echo hi will immediately print “hi” instead of after 10 seconds, because echo runs immediately and exits, not waiting for sleep to finish. Since the goal of the sh.c is to be as simple as possible, it doesn’t try to avoid creating interior processes.</p>
<p>Pipes may seem no more powerful than temporary files: the pipeline</p>
<p>echo hello world | wc</p>
<p>could be implemented without pipes as</p>
<p>echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</p>
<p>Pipes have at least four advantages over temporary files in this situation. First, pipes automatically clean themselves up; with the file redirection, a shell would have to be careful to remove /tmp/xyz when done. Second, pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data. Third, pipes allow for parallel execution of pipeline stages, while the file approach requires the first program to finish before the second starts. Fourth, if you are implementing inter-process communication, pipes’ blocking reads and writes are more efficient than the non-blocking semantics of files.</p>
<h2 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4     File system"></a><strong>1.4</strong>     <strong>File system</strong></h2><p>The xv6 file system provides data files, which contain uninterpreted byte arrays, and directories, which contain named references to data files and other directories. The directories form a tree, starting at a special directory called the <em>root</em>. A <em>path</em> like /a/b/c refers to the file or directory named c inside the directory named b inside the directory named a in the root directory /. Paths that don’t begin with / are evaluated relative to the calling process’s <em>current directory</em>, which can be changed with the chdir system call. Both these code fragments open the same file (assuming all the directories involved exist):</p>
<p>chdir(“/a”);</p>
<p>chdir(“b”);</p>
<p>open(“c”, O_RDONLY);</p>
<p>open(“/a/b/c”, O_RDONLY);</p>
<p>The first fragment changes the process’s current directory to /a/b; the second neither refers to nor changes the process’s current directory.</p>
<p>There are system calls to create new files and directories: mkdir creates a new directory, open with the O_CREATE flag creates a new data file, and mknod creates a new device file. This example illustrates all three:</p>
<p>mkdir(“/dir”);</p>
<p>fd = open(“/dir/file”, O_CREATE|O_WRONLY); close(fd);</p>
<p>mknod(“/console”, 1, 1);</p>
<p>Mknod creates a special file that refers to a device. Associated with a device file are the major and minor device numbers (the two arguments to mknod), which uniquely identify a kernel device. When a process later opens a device file, the kernel diverts read and write system calls to the kernel device implementation instead of passing them to the file system.</p>
<p>A file’s name is distinct from the file itself; the same underlying file, called an <em>inode</em>, can have multiple names, called <em>links</em>. Each link consists of an entry in a directory; the entry contains a file name and a reference to an inode. An inode holds <em>metadata</em> about a file, including its type (file or directory or device), its length, the location of the file’s content on disk, and the number of links to a file.</p>
<p>The fstat system call retrieves information from the inode that a file descriptor refers to. It fills in a struct stat, defined in stat.h <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/stat.h">(kernel/stat.h) </a>as:</p>
<table>
<thead>
<tr>
<th>#define</th>
<th>T_DIR</th>
<th>1</th>
<th>//</th>
<th>Directory</th>
</tr>
</thead>
<tbody><tr>
<td>#define</td>
<td>T_FILE</td>
<td>2</td>
<td>//</td>
<td>File</td>
</tr>
<tr>
<td>#define</td>
<td>T_DEVICE</td>
<td>3</td>
<td>//</td>
<td>Device</td>
</tr>
</tbody></table>
<p>struct stat {</p>
<p>int dev;   // File system’s disk device uint ino;  // Inode number</p>
<p>short type; // Type of file</p>
<p>short nlink; // Number of links to file uint64 size; // Size of file in bytes</p>
<p>};</p>
<p>The link system call creates another file system name referring to the same inode as an exist- ing file. This fragment creates a new file named both a and b.</p>
<p>open(“a”, O_CREATE|O_WRONLY);</p>
<p>link(“a”, “b”);</p>
<p>Reading from or writing to a is the same as reading from or writing to b. Each inode is identified by a unique <em>inode number</em>. After the code sequence above, it is possible to determine that a and b refer to the same underlying contents by inspecting the result of fstat: both will return the same inode number (ino), and the nlink count will be set to 2.</p>
<p>The unlink system call removes a name from the file system. The file’s inode and the disk space holding its content are only freed when the file’s link count is zero and no file descriptors refer to it. Thus adding</p>
<p>unlink(“a”);</p>
<p>to the last code sequence leaves the inode and file content accessible as b. Furthermore,</p>
<p>fd = open(“/tmp/xyz”, O_CREATE|O_RDWR); unlink(“/tmp/xyz”);</p>
<p>is an idiomatic way to create a temporary inode with no name that will be cleaned up when the process closes fd or exits.</p>
<p>Unix provides file utilities callable from the shell as user-level programs, for example mkdir, ln, and rm. This design allows anyone to extend the command-line interface by adding new user- level programs. In hindsight this plan seems obvious, but other systems designed at the time of Unix often built such commands into the shell (and built the shell into the kernel).</p>
<p>One exception is cd, which is built into the shell <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L160">(user/sh.c:160)</a>. cd must change the current working directory of the shell itself. If cd were run as a regular command, then the shell would fork a child process, the child process would run cd, and cd would change the <em>child</em> ’s working directory. The parent’s (i.e., the shell’s) working directory would not change.</p>
<h2 id="1-5-Real-world"><a href="#1-5-Real-world" class="headerlink" title="1.5     Real world"></a><strong>1.5</strong>     <strong>Real world</strong></h2><p>Unix’s combination of “standard” file descriptors, pipes, and convenient shell syntax for operations on them was a major advance in writing general-purpose reusable programs. The idea sparked a culture of “software tools” that was responsible for much of Unix’s power and popularity, and the shell was the first so-called “scripting language.” The Unix system call interface persists today in systems like BSD, Linux, and Mac OS X.</p>
<p>The Unix system call interface has been standardized through the Portable Operating System Interface (POSIX) standard. Xv6 is <em>not</em> POSIX compliant: it is missing many system calls (in- cluding basic ones such as lseek), and many of the system calls it does provide differ from the standard. Our main goals for xv6 are simplicity and clarity while providing a simple UNIX-like system-call interface. Several people have extended xv6 with a few more system calls and a sim- ple C library in order to run basic Unix programs. Modern kernels, however, provide many more system calls, and many more kinds of kernel services, than xv6. For example, they support net- working, windowing systems, user-level threads, drivers for many devices, and so on. Modern kernels evolve continuously and rapidly, and offer many features beyond POSIX.</p>
<p>Unix unified access to multiple types of resources (files, directories, and devices) with a single set of file-name and file-descriptor interfaces. This idea can be extended to more kinds of resources; a good example is Plan 9 [13], which applied the “resources are files” concept to networks, graph- ics, and more. However, most Unix-derived operating systems have not followed this route.</p>
<p>The file system and file descriptors have been powerful abstractions. Even so, there are other models for operating system interfaces. Multics, a predecessor of Unix, abstracted file storage in a way that made it look like memory, producing a very different flavor of interface. The complexity of the Multics design had a direct influence on the designers of Unix, who tried to build something simpler.</p>
<p>Xv6 does not provide a notion of users or of protecting one user from another; in Unix terms, all xv6 processes run as root.</p>
<p>This book examines how xv6 implements its Unix-like interface, but the ideas and concepts apply to more than just Unix. Any operating system must multiplex processes onto the underlying hardware, isolate processes from each other, and provide mechanisms for controlled inter-process communication. After studying xv6, you should be able to look at other, more complex operating systems and see the concepts underlying xv6 in those systems as well.</p>
<h2 id="1-6-Exercises"><a href="#1-6-Exercises" class="headerlink" title="1.6     Exercises"></a><strong>1.6</strong>     <strong>Exercises</strong></h2><p>\1.   Write a program that uses UNIX system calls to “ping-pong” a byte between two processes over a pair of pipes, one for each direction. Measure the program’s performance, in ex- changes per second.</p>
<h1 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2  Operating system organization"></a><strong>Chapter 2</strong>  Operating system organization</h1><hr>
<p>A key requirement for an operating system is to support several activities at once. For example, using the system call interface described in Chapter 1 a process can start new processes with fork. The operating system must <em>time-share</em> the resources of the computer among these processes. For example, even if there are more processes than there are hardware CPUs, the operating system must ensure that all of the processes get a chance to execute. The operating system must also arrange for <em>isolation</em> between the processes. That is, if one process has a bug and malfunctions, it shouldn’t affect processes that don’t depend on the buggy process. Complete isolation, however, is too strong, since it should be possible for processes to intentionally interact; pipelines are an example. Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.</p>
<p>This chapter provides an overview of how operating systems are organized to achieve these three requirements. It turns out there are many ways to do so, but this text focuses on mainstream designs centered around a <em>monolithic kernel</em>, which is used by many Unix operating systems. This chapter also provides an overview of an xv6 process, which is the unit of isolation in xv6, and the creation of the first process when xv6 starts.</p>
<p>Xv6 runs on a <em>multi-core</em>1 RISC-V microprocessor, and much of its low-level functionality (for example, its process implementation) is specific to RISC-V. RISC-V is a 64-bit CPU, and xv6 is written in “LP64” C, which means long (L) and pointers (P) in the C programming language are 64 bits, but int is 32-bit. This book assumes the reader has done a bit of machine-level programming on some architecture, and will introduce RISC-V-specific ideas as they come up. A useful reference for RISC-V is “The RISC-V Reader: An Open Architecture Atlas” [12]. The user-level ISA [2] and the privileged architecture [1] are the official specifications.</p>
<p>The CPU in a complete computer is surrounded by support hardware, much of it in the form of I/O interfaces. Xv6 is written for the support hardware simulated by qemu’s “-machine virt” option. This includes RAM, a ROM containing boot code, a serial connection to the user’s key- board/screen, and a disk for storage.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image007.gif" alt="img"></td>
</tr>
</tbody></table>
<p>1By “multi-core” this text means multiple CPUs that share memory but execute in parallel, each with its own set of</p>
<p>registers. This text sometimes uses the term <em>multiprocessor</em> as a synonym for multi-core, though multiprocessor can also refer more specifically to a computer with several distinct processor chips.</p>
<h2 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1     Abstracting physical resources"></a><strong>2.1</strong>     <strong>Abstracting physical resources</strong></h2><p>The first question one might ask when encountering an operating system is why have it at all? That is, one could implement the system calls in Figure 1.2 as a library, with which applications link. In this plan, each application could even have its own library tailored to its needs. Applications could directly interact with hardware resources and use those resources in the best way for the application (e.g., to achieve high or predictable performance). Some operating systems for embedded devices or real-time systems are organized in this way.</p>
<p>The downside of this library approach is that, if there is more than one application running, the applications must be well-behaved. For example, each application must periodically give up the CPU so that other applications can run. Such a <em>cooperative</em> time-sharing scheme may be OK if all applications trust each other and have no bugs. It’s more typical for applications to not trust each other, and to have bugs, so one often wants stronger isolation than a cooperative scheme provides. To achieve strong isolation it’s helpful to forbid applications from directly accessing sensitive hardware resources, and instead to abstract the resources into services. For example, Unix applica- tions interact with storage only through the file system’s open, read, write, and close system calls, instead of reading and writing the disk directly. This provides the application with the con- venience of pathnames, and it allows the operating system (as the implementer of the interface) to manage the disk. Even if isolation is not a concern, programs that interact intentionally (or just wish to keep out of each other’s way) are likely to find a file system a more convenient abstraction</p>
<p>than direct use of the disk.</p>
<p>Similarly, Unix transparently switches hardware CPUs among processes, saving and restor- ing register state as necessary, so that applications don’t have to be aware of time sharing. This transparency allows the operating system to share CPUs even if some applications are in infinite loops.</p>
<p>As another example, Unix processes use exec to build up their memory image, instead of directly interacting with physical memory. This allows the operating system to decide where to place a process in memory; if memory is tight, the operating system might even store some of a process’s data on disk. Exec also provides users with the convenience of a file system to store executable program images.</p>
<p>Many forms of interaction among Unix processes occur via file descriptors. Not only do file descriptors abstract away many details (e.g., where data in a pipe or file is stored), they are also defined in a way that simplifies interaction. For example, if one application in a pipeline fails, the kernel generates an end-of-file signal for the next process in the pipeline.</p>
<p>The system-call interface in Figure 1.2 is carefully designed to provide both programmer con- venience and the possibility of strong isolation. The Unix interface is not the only way to abstract resources, but it has proven to be a very good one.</p>
<p><strong>2.2</strong>     <strong>User mode, supervisor mode, and system calls</strong></p>
<p>Strong isolation requires a hard boundary between applications and the operating system. If the application makes a mistake, we don’t want the operating system to fail or other applications to</p>
<p>fail. Instead, the operating system should be able to clean up the failed application and continue running other applications. To achieve strong isolation, the operating system must arrange that applications cannot modify (or even read) the operating system’s data structures and instructions and that applications cannot access other processes’ memory.</p>
<p>CPUs provide hardware support for strong isolation. For example, RISC-V has three modes in which the CPU can execute instructions: <em>machine mode</em>, <em>supervisor mode</em>, and <em>user mode</em>. In- structions executing in machine mode have full privilege; a CPU starts in machine mode. Machine mode is mostly intended for configuring a computer. Xv6 executes a few lines in machine mode and then changes to supervisor mode.</p>
<p>In supervisor mode the CPU is allowed to execute <em>privileged instructions</em>: for example, en- abling and disabling interrupts, reading and writing the register that holds the address of a page table, etc. If an application in user mode attempts to execute a privileged instruction, then the CPU doesn’t execute the instruction, but switches to supervisor mode so that supervisor-mode code can terminate the application, because it did something it shouldn’t be doing. Figure 1.1 in Chapter 1 illustrates this organization. An application can execute only user-mode instructions (e.g., adding numbers, etc.) and is said to be running in <em>user space</em>, while the software in supervisor mode can also execute privileged instructions and is said to be running in <em>kernel space</em>. The software running in kernel space (or in supervisor mode) is called the <em>kernel</em>.</p>
<p>An application that wants to invoke a kernel function (e.g., the read system call in xv6) must transition to the kernel. CPUs provide a special instruction that switches the CPU from user mode to supervisor mode and enters the kernel at an entry point specified by the kernel. (RISC-V provides the ecall instruction for this purpose.) Once the CPU has switched to supervisor mode, the kernel can then validate the arguments of the system call, decide whether the application is allowed to perform the requested operation, and then deny it or execute it. It is important that the kernel control the entry point for transitions to supervisor mode; if the application could decide the kernel entry point, a malicious application could, for example, enter the kernel at a point where the validation of arguments is skipped.</p>
<p><strong>2.3</strong>     <strong>Kernel</strong> <strong>organization</strong></p>
<p>A key design question is what part of the operating system should run in supervisor mode. One possibility is that the entire operating system resides in the kernel, so that the implementations of all system calls run in supervisor mode. This organization is called a <em>monolithic kernel</em>.</p>
<p>In this organization the entire operating system runs with full hardware privilege. This organi- zation is convenient because the OS designer doesn’t have to decide which part of the operating system doesn’t need full hardware privilege. Furthermore, it is easier for different parts of the op- erating system to cooperate. For example, an operating system might have a buffer cache that can be shared both by the file system and the virtual memory system.</p>
<p>A downside of the monolithic organization is that the interfaces between different parts of the operating system are often complex (as we will see in the rest of this text), and therefore it is easy for an operating system developer to make a mistake. In a monolithic kernel, a mistake is fatal, because an error in supervisor mode will often cause the kernel to fail. If the kernel fails,</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image009.gif" alt="img"></p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image010.gif" alt="img"><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image012.gif" alt="img">Figure 2.1: A microkernel with a file-system server</p>
<p>the computer stops working, and thus all applications fail too. The computer must reboot to start again.</p>
<p>To reduce the risk of mistakes in the kernel, OS designers can minimize the amount of operating system code that runs in supervisor mode, and execute the bulk of the operating system in user mode. This kernel organization is called a <em>microkernel</em>.</p>
<p>Figure 2.1 illustrates this microkernel design. In the figure, the file system runs as a user-level process. OS services running as processes are called servers. To allow applications to interact with the file server, the kernel provides an inter-process communication mechanism to send messages from one user-mode process to another. For example, if an application like the shell wants to read or write a file, it sends a message to the file server and waits for a response.</p>
<p>In a microkernel, the kernel interface consists of a few low-level functions for starting applica- tions, sending messages, accessing device hardware, etc. This organization allows the kernel to be relatively simple, as most of the operating system resides in user-level servers.</p>
<p>Xv6 is implemented as a monolithic kernel, like most Unix operating systems. Thus, the xv6 kernel interface corresponds to the operating system interface, and the kernel implements the com- plete operating system. Since xv6 doesn’t provide many services, its kernel is smaller than some microkernels, but conceptually xv6 is monolithic.</p>
<h2 id="2-4-Code-xv6-organization"><a href="#2-4-Code-xv6-organization" class="headerlink" title="2.4     Code: xv6 organization"></a><strong>2.4</strong>     <strong>Code: xv6 organization</strong></h2><p>The xv6 kernel source is in the kernel/ sub-directory. The source is divided into files, following a rough notion of modularity; Figure 2.2 lists the files. The inter-module interfaces are defined in defs.h <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/defs.h">(kernel/defs.h)</a>.</p>
<h2 id="2-5-Process-overview"><a href="#2-5-Process-overview" class="headerlink" title="2.5     Process overview"></a><strong>2.5</strong>     <strong>Process overview</strong></h2><p>The unit of isolation in xv6 (as in other Unix operating systems) is a <em>process</em>. The process ab- straction prevents one process from wrecking or spying on another process’s memory, CPU, file descriptors, etc. It also prevents a process from wrecking the kernel itself, so that a process can’t subvert the kernel’s isolation mechanisms. The kernel must implement the process abstraction with care because a buggy or malicious application may trick the kernel or hardware into doing something bad (e.g., circumventing isolation). The mechanisms used by the kernel to implement</p>
<h4 id="File"><a href="#File" class="headerlink" title="File"></a><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image013.gif" alt="img">File</h4><p>bio.c console.c entry.S exec.c file.c</p>
<p>fs.c kalloc.c kernelvec.S log.c main.c pipe.c plic.c printf.c proc.c sleeplock.c spinlock.c start.c string.c swtch.S syscall.c sysfile.c sysproc.c</p>
<p>trampoline.S trap.c</p>
<p>uart.c virtio_disk.c vm.c</p>
<p>Description</p>
<p>Disk block cache for the file system. Connect to the user keyboard and screen. Very first boot instructions.</p>
<p>exec() system call.</p>
<p>File descriptor support. File system.</p>
<p>Physical page allocator.</p>
<p>Handle traps from kernel, and timer interrupts. File system logging and crash recovery.</p>
<p>Control initialization of other modules during boot. Pipes.</p>
<p>RISC-V interrupt controller. Formatted output to the console. Processes and scheduling.</p>
<p>Locks that yield the CPU. Locks that don’t yield the CPU. Early machine-mode boot code. C string and byte-array library. Thread switching.</p>
<p>Dispatch system calls to handling function. File-related system calls.</p>
<p>Process-related system calls.</p>
<p>Assembly code to switch between user and kernel.</p>
<p>C code to handle and return from traps and interrupts. Serial-port console device driver.</p>
<p>Disk device driver.</p>
<p>Manage page tables and address spaces. Figure 2.2: Xv6 kernel source files.</p>
<p>processes include the user/supervisor mode flag, address spaces, and time-slicing of threads.</p>
<p>To help enforce isolation, the process abstraction provides the illusion to a program that it has its own private machine. A process provides a program with what appears to be a private memory system, or <em>address space</em>, which other processes cannot read or write. A process also provides the program with what appears to be its own CPU to execute the program’s instructions.</p>
<p>Xv6 uses page tables (which are implemented by hardware) to give each process its own ad- dress space. The RISC-V page table translates (or “maps”) a <em>virtual address</em> (the address that an RISC-V instruction manipulates) to a <em>physical address</em> (an address that the CPU chip sends to main memory).</p>
<p>Xv6 maintains a separate page table for each process that defines that process’s address space. As illustrated in Figure 2.3, an address space includes the process’s <em>user memory</em> starting at virtual</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image014.gif" alt="img"></p>
<p>​                                                     trampoline                            trapframe                                                 heap                            user stack                            user text and data                                    </p>
<p>MAXVA</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image015.gif" alt="img">0</p>
<p>Figure 2.3: Layout of a process’s virtual address space</p>
<p>​                 <em>−</em>                </p>
<p>address zero. Instructions come first, followed by global variables, then the stack, and finally a “heap” area (for malloc) that the process can expand as needed. There are a number of factors that limit the maximum size of a process’s address space: pointers on the RISC-V are 64 bits wide; the hardware only uses the low 39 bits when looking up virtual addresses in page tables; and xv6 only uses 38 of those 39 bits. Thus, the maximum address is 238 1 = 0x3fffffffff, which is MAXVA <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h#L348">(kernel/riscv.h:348)</a>. At the top of the address space xv6 reserves a page for a <em>trampoline</em> and a page mapping the process’s <em>trapframe</em> to switch to the kernel, as we will explain in Chapter 4.</p>
<p>The xv6 kernel maintains many pieces of state for each process, which it gathers into a struct proc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.h#L86">(kernel/proc.h:86)</a>. A process’s most important pieces of kernel state are its page table, its kernel   stack, and its run state. We’ll use the notation p-&gt;xxx to refer to elements of the proc structure;</p>
<p>for example, p-&gt;pagetable is a pointer to the process’s page table.</p>
<p>Each process has a thread of execution (or <em>thread</em> for short) that executes the process’s instruc- tions. A thread can be suspended and later resumed. To switch transparently between processes, the kernel suspends the currently running thread and resumes another process’s thread. Much of the state of a thread (local variables, function call return addresses) is stored on the thread’s stacks. Each process has two stacks: a user stack and a kernel stack (p-&gt;kstack). When the process is executing user instructions, only its user stack is in use, and its kernel stack is empty. When the process enters the kernel (for a system call or interrupt), the kernel code executes on the process’s kernel stack; while a process is in the kernel, its user stack still contains saved data, but isn’t ac- tively used. A process’s thread alternates between actively using its user stack and its kernel stack. The kernel stack is separate (and protected from user code) so that the kernel can execute even if a process has wrecked its user stack.</p>
<p>A process can make a system call by executing the RISC-V ecall instruction. This instruction raises the hardware privilege level and changes the program counter to a kernel-defined entry point. The code at the entry point switches to a kernel stack and executes the kernel instructions that implement the system call. When the system call completes, the kernel switches back to the user</p>
<p>stack and returns to user space by calling the sret instruction, which lowers the hardware privilege level and resumes executing user instructions just after the system call instruction. A process’s thread can “block” in the kernel to wait for I/O, and resume where it left off when the I/O has finished.</p>
<p>p-&gt;state indicates whether the process is allocated, ready to run, running, waiting for I/O, or exiting.</p>
<p>p-&gt;pagetable holds the process’s page table, in the format that the RISC-V hardware ex- pects. xv6 causes the paging hardware to use a process’s p-&gt;pagetable when executing that process in user space. A process’s page table also serves as the record of the addresses of the physical pages allocated to store the process’s memory.</p>
<p><strong>2.6</strong>     <strong>Code: starting xv6 and the first process</strong></p>
<p>To make xv6 more concrete, we’ll outline how the kernel starts and runs the first process. The subsequent chapters will describe the mechanisms that show up in this overview in more detail.</p>
<p>When the RISC-V computer powers on, it initializes itself and runs a boot loader which is stored in read-only memory. The boot loader loads the xv6 kernel into memory. Then, in machine mode, the CPU executes xv6 starting at _entry <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/entry.S#L6">(kernel/entry.S:6)</a>. The RISC-V starts with paging hardware disabled: virtual addresses map directly to physical addresses.</p>
<p>The loader loads the xv6 kernel into memory at physical address 0x80000000. The reason it places the kernel at 0x80000000 rather than 0x0 is because the address range 0x0:0x80000000 contains I/O devices.</p>
<p>The instructions at _entry set up a stack so that xv6 can run C code. Xv6 declares space for an initial stack, stack0, in the file start.c <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/start.c#L11">(kernel/start.c:11)</a>. The code at _entry loads the stack pointer register sp with the address stack0+4096, the top of the stack, because the stack on RISC-V grows down. Now that the kernel has a stack, _entry calls into C code at start <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/start.c#L21">(kernel/start.c:21)</a>.</p>
<p>The function start performs some configuration that is only allowed in machine mode, and then switches to supervisor mode. To enter supervisor mode, RISC-V provides the instruction mret. This instruction is most often used to return from a previous call from supervisor mode to machine mode. start isn’t returning from such a call, and instead sets things up as if there had been one: it sets the previous privilege mode to supervisor in the register mstatus, it sets the return address to main by writing main’s address into the register mepc, disables virtual address translation in supervisor mode by writing 0 into the page-table register satp, and delegates all interrupts and exceptions to supervisor mode.</p>
<p>Before jumping into supervisor mode, start performs one more task: it programs the clock chip to generate timer interrupts. With this housekeeping out of the way, start “returns” to super- visor mode by calling mret. This causes the program counter to change to main <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/main.c#L11">(kernel/main.c:11)</a>. After main <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/main.c#L11">(kernel/main.c:11) </a>initializes several devices and subsystems, it creates the first pro- cess by calling userinit <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L212">(kernel/proc.c:212)</a>. The first process executes a small program written in RISC-V assembly, initcode.S <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/initcode.S#L1">(user/initcode.S:1)</a>, which re-enters the kernel by invoking the exec system call. As we saw in Chapter 1, exec replaces the memory and registers of the current</p>
<p>process with a new program (in this case, /init). Once the kernel has completed exec, it returns to user space in the /init process. Init <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/init.c#L15">(user/init.c:15) </a>creates a new console device file if needed and then opens it as file descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up.</p>
<p><strong>2.7</strong>     <strong>Real world</strong></p>
<p>In the real world, one can find both monolithic kernels and microkernels. Many Unix kernels are monolithic. For example, Linux has a monolithic kernel, although some OS functions run as user- level servers (e.g., the windowing system). Kernels such as L4, Minix, and QNX are organized as a microkernel with servers, and have seen wide deployment in embedded settings.</p>
<p>Most operating systems have adopted the process concept, and most processes look similar to xv6’s. Modern operating systems, however, support several threads within a process, to allow a single process to exploit multiple CPUs. Supporting multiple threads in a process involves quite a bit of machinery that xv6 doesn’t have, including potential interface changes (e.g., Linux’s clone, a variant of fork), to control which aspects of a process threads share.</p>
<p><strong>2.8</strong>     <strong>Exercises</strong></p>
<p>\1.   You can use gdb to observe the very first kernel-to-user transition. Run make qemu-gdb.</p>
<p>In another window, in the same directory, run gdb. Type the gdb command break *0x3ffffff10e, which sets a breakpoint at the sret instruction in the kernel that jumps into user space. Type</p>
<p>the continue gdb command. gdb should stop at the breakpoint, about to execute sret. Type stepi. gdb should now indicate that it is executing at address 0x0, which is in user space at the start of initcode.S.</p>
<p><strong>Chapter 3 Page tables</strong></p>
<p>Page tables are the mechanism through which the operating system provides each process with its own private address space and memory. Page tables determine what memory addresses mean, and what parts of physical memory can be accessed. They allow xv6 to isolate different process’s ad- dress spaces and to multiplex them onto a single physical memory. Page tables also provide a level of indirection that allows xv6 to perform a few tricks: mapping the same memory (a trampoline page) in several address spaces, and guarding kernel and user stacks with an unmapped page. The rest of this chapter explains the page tables that the RISC-V hardware provides and how xv6 uses them.</p>
<p><strong>3.1</strong>     <strong>Paging hardware</strong></p>
<p>As a reminder, RISC-V instructions (both user and kernel) manipulate virtual addresses. The ma- chine’s RAM, or physical memory, is indexed with physical addresses. The RISC-V page table hardware connects these two kinds of addresses, by mapping each virtual address to a physical address.</p>
<p>xv6 runs on Sv39 RISC-V, which means that only the bottom 39 bits of a 64-bit virtual address are used; the top 25 bits are not used. In this Sv39 configuration, a RISC-V page table is logically an array of 227 (134,217,728) <em>page table entries (PTEs)</em>. Each PTE contains a 44-bit physical page number (PPN) and some flags. The paging hardware translates a virtual address by using the top 27 bits of the 39 bits to index into the page table to find a PTE, and making a 56-bit physical address whose top 44 bits come from the PPN in the PTE and whose bottom 12 bits are copied from the original virtual address. Figure 3.1 shows this process with a logical view of the page table as a simple array of PTEs (see Figure 3.2 for a fuller story). A page table gives the operating system control over virtual-to-physical address translations at the granularity of aligned chunks of 4096</p>
<p>(212) bytes. Such a chunk is called a <em>page</em>.</p>
<p>In Sv39 RISC-V, the top 25 bits of a virtual address are not used for translation; in the future, RISC-V may use those bits to define more levels of translation. The physical address also has room for growth: there is room in the PTE format for the physical page number to grow by another 10 bits.</p>
<p>Virtual address</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image016.gif" alt="img">25              27               12</p>
<p>64</p>
<p>44          12</p>
<p>Physical Address</p>
<p>Figure 3.1: RISC-V virtual and physical addresses, with a simplified logical page table.</p>
<p>As Figure 3.2 shows, the actual translation happens in three steps. A page table is stored in physical memory as a three-level tree. The root of the tree is a 4096-byte page-table page that contains 512 PTEs, which contain the physical addresses for page-table pages in the next level of the tree. Each of those pages contains 512 PTEs for the final level in the tree. The paging hardware uses the top 9 bits of the 27 bits to select a PTE in the root page-table page, the middle 9 bits to select a PTE in a page-table page in the next level of the tree, and the bottom 9 bits to select the final PTE.</p>
<p>If any of the three PTEs required to translate an address is not present, the paging hardware raises a <em>page-fault exception</em>, leaving it up to the kernel to handle the exception (see Chapter 4). This three-level structure allows a page table to omit entire page table pages in the common case in which large ranges of virtual addresses have no mappings.</p>
<p>Each PTE contains flag bits that tell the paging hardware how the associated virtual address is allowed to be used. PTE_V indicates whether the PTE is present: if it is not set, a reference to the page causes an exception (i.e. is not allowed). PTE_R controls whether instructions are allowed to read to the page. PTE_W controls whether instructions are allowed to write to the page. PTE_X controls whether the CPU may interpret the content of the page as instructions and execute them. PTE_U controls whether instructions in user mode are allowed to access the page; if PTE_U is not set, the PTE can be used only in supervisor mode. Figure 3.2 shows how it all works. The flags and all other page hardware-related structures are defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h">(kernel/riscv.h)</a></p>
<p>To tell the hardware to use a page table, the kernel must write the physical address of the root page-table page into the satp register. Each CPU has its own satp. A CPU will translate all addresses generated by subsequent instructions using the page table pointed to by its own satp. Each CPU has its own satp so that different CPUs can run different processes, each with a private address space described by its own page table.</p>
<p>A few notes about terms. Physical memory refers to storage cells in DRAM. A byte of physical memory has an address, called a physical address. Instructions use only virtual addresses, which the paging hardware translates to physical addresses, and then sends to the DRAM hardware to read</p>
<p>Virtual address                       Physical Address</p>
<p>9        9        9      12                        44            12</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image021.gif" alt="img"></p>
<p>63                  53                        10 9 8 7 6 5 4 3 2 1 0</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image022.gif" alt="img">Reserved</p>
<p>Physical Page Number</p>
<p>RSWD A G U XWR V</p>
<p>V - Valid</p>
<p>R - Readable W - Writable</p>
<p>X - Executable U - User</p>
<p>G - Global</p>
<p>A - Accessed</p>
<p>D - Dirty (0 in page directory)</p>
<p>Reserved for supervisor software</p>
<p>Figure 3.2: RISC-V address translation details.</p>
<p>or write storage. Unlike physical memory and virtual addresses, virtual memory isn’t a physical object, but refers to the collection of abstractions and mechanisms the kernel provides to manage physical memory and virtual addresses.</p>
<p><strong>3.2</strong>     <strong>Kernel</strong> <strong>address space</strong></p>
<p>Xv6 maintains one page table per process, describing each process’s user address space, plus a sin- gle page table that describes the kernel’s address space. The kernel configures the layout of its ad- dress space to give itself access to physical memory and various hardware resources at predictable virtual addresses. Figure 3.3 shows how this layout maps kernel virtual addresses to physical ad- dresses. The file <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/memlayout.h">(kernel/memlayout.h) </a>declares the constants for xv6’s kernel memory layout.</p>
<p>QEMU simulates a computer that includes RAM (physical memory) starting at physical ad- dress 0x80000000 and continuing through at least 0x86400000, which xv6 calls PHYSTOP. The QEMU simulation also includes I/O devices such as a disk interface. QEMU exposes the de- vice interfaces to software as <em>memory-mapped</em> control registers that sit below 0x80000000 in the physical address space. The kernel can interact with the devices by reading/writing these special physical addresses; such reads and writes communicate with the device hardware rather than with RAM. Chapter 4 explains how xv6 interacts with devices.</p>
<p>The kernel gets at RAM and memory-mapped device registers using “direct mapping;” that is, mapping the resources at virtual addresses that are equal to the physical address. For example,</p>
<p>MAXVA</p>
<p>​                                Free memory                </p>
<p>PHYSTOP (0x86400000)</p>
<p>Virtual Addresses</p>
<p>​                 Guard page                </p>
<p>​                    Kstack 0                                        Guard page                                        Trampoline                   Ks.ta.c.k 1</p>
<p>R-X</p>
<p>— RW-</p>
<p>-–</p>
<p>​                                               Physical    memory (RAM)                </p>
<p>RW-</p>
<p>2^56-1</p>
<p>Physical Addresses</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image023.gif" alt="文本框: Unused"></td>
</tr>
</tbody></table>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image024.gif" alt="文本框: RW-"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image025.gif" alt="img"></td>
</tr>
</tbody></table>
<p>KERNBASE (0x80000000)</p>
<p>​                 UART0                </p>
<p>​                    RW-                                        UART0                                        VIRTIO disk                                        VIRTIO disk                                        Unused    and other I/O    devices                                        RW-                                             Kernel text                   0x10001000</p>
<p>0x10000000</p>
<p>​                      RW-                </p>
<p>​                    PLIC                                        PLIC                                        RW-                   0x0C000000</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image026.gif" alt="文本框: Unused "></td>
</tr>
</tbody></table>
<pre><code>                 CLINT                                        CLINT                   0x02000000
</code></pre>
<p>​                 Unused                </p>
<p>​                    boot ROM                   0x1000</p>
<p>0                                       0</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image031.gif" alt="img">Figure 3.3: On the left, xv6’s kernel address space. RWX refer to PTE read, write, and execute permissions. On the right, the RISC-V physical address space that xv6 expects to see.</p>
<p>the kernel itself is located at KERNBASE=0x80000000 in both the virtual address space and in physical memory. Direct mapping simplifies kernel code that reads or writes physical memory. For example, when fork allocates user memory for the child process, the allocator returns the physical address of that memory; fork uses that address directly as a virtual address when it is copying the parent’s user memory to the child.</p>
<p>There are a couple of kernel virtual addresses that aren’t direct-mapped:</p>
<p>•   The trampoline page. It is mapped at the top of the virtual address space; user page tables have this same mapping. Chapter 4 discusses the role of the trampoline page, but we see here an interesting use case of page tables; a physical page (holding the trampoline code) is mapped twice in the virtual address space of the kernel: once at top of the virtual address space and once with a direct mapping.</p>
<p>•   The kernel stack pages. Each process has its own kernel stack, which is mapped high so that below it xv6 can leave an unmapped <em>guard page</em>. The guard page’s PTE is invalid (i.e., PTE_V is not set), so that if the kernel overflows a kernel stack, it will likely cause an excep- tion and the kernel will panic. Without a guard page an overflowing stack would overwrite other kernel memory, resulting in incorrect operation. A panic crash is preferable.</p>
<p>While the kernel uses its stacks via the high-memory mappings, they are also accessible to the kernel through a direct-mapped address. An alternate design might have just the direct mapping, and use the stacks at the direct-mapped address. In that arrangement, however, providing guard pages would involve unmapping virtual addresses that would otherwise refer to physical memory, which would then be hard to use.</p>
<p>The kernel maps the pages for the trampoline and the kernel text with the permissions PTE_R and PTE_X. The kernel reads and executes instructions from these pages. The kernel maps the other pages with the permissions PTE_R and PTE_W, so that it can read and write the memory in those pages. The mappings for the guard pages are invalid.</p>
<p><strong>3.3</strong>     <strong>Code: creating an address space</strong></p>
<p>Most of the xv6 code for manipulating address spaces and page tables resides in vm.c <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L1">(ker-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L1">nel/vm.c:1)</a>. The central data structure is pagetable_t, which is really a pointer to a RISC-V root page-table page; a pagetable_t may be either the kernel page table, or one of the per- process page tables. The central functions are walk, which finds the PTE for a virtual address, and mappages, which installs PTEs for new mappings. Functions starting with kvm manipulate the kernel page table; functions starting with uvm manipulate a user page table; other functions are used for both. copyout and copyin copy data to and from user virtual addresses provided as system call arguments; they are in vm.c because they need to explicitly translate those addresses in order to find the corresponding physical memory.</p>
<p>Early in the boot sequence, main calls kvminit <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L22">(kernel/vm.c:22) </a>to create the kernel’s page table. This call occurs before xv6 has enabled paging on the RISC-V, so addresses refer directly to physical memory. Kvminit first allocates a page of physical memory to hold the root page-table page. Then it calls kvmmap to install the translations that the kernel needs. The translations include the kernel’s instructions and data, physical memory up to PHYSTOP, and memory ranges which are actually devices.</p>
<p>kvmmap <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L118">(kernel/vm.c:118)</a> calls mappages <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L149">(kernel/vm.c:149)</a>, which installs mappings into a page table for a range of virtual addresses to a corresponding range of physical addresses. It does this separately for each virtual address in the range, at page intervals. For each virtual address to be mapped, mappages calls walk to find the address of the PTE for that address. It then initializes the PTE to hold the relevant physical page number, the desired permissions (PTE_W, PTE_X, and/or PTE_R), and PTE_V to mark the PTE as valid <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L161">(kernel/vm.c:161)</a>.</p>
<p>walk <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L72">(kernel/vm.c:72) </a>mimics the RISC-V paging hardware as it looks up the PTE for a virtual address (see Figure 3.2). walk descends the 3-level page table 9 bits at the time. It uses each level’s 9 bits of virtual address to find the PTE of either the next-level page table or the final page</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L78">(kernel/vm.c:78)</a>. If the PTE isn’t valid, then the required page hasn’t yet been allocated; if the alloc argument is set, walk allocates a new page-table page and puts its physical address in the PTE. It returns the address of the PTE in the lowest layer in the tree <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L88">(kernel/vm.c:88)</a>.</p>
<p>The above code depends on physical memory being direct-mapped into the kernel virtual ad- dress space. For example, as walk descends levels of the page table, it pulls the (physical) address of the next-level-down page table from a PTE <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L80">(kernel/vm.c:80)</a>, and then uses that address as a virtual address to fetch the PTE at the next level down <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L78">(kernel/vm.c:78)</a>.</p>
<p>main calls kvminithart <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L53">(kernel/vm.c:53) </a>to install the kernel page table. It writes the phys- ical address of the root page-table page into the register satp. After this the CPU will translate addresses using the kernel page table. Since the kernel uses an identity mapping, the now virtual address of the next instruction will map to the right physical memory address.</p>
<p>procinit <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L26">(kernel/proc.c:26)</a>, which is called from main, allocates a kernel stack for each pro- cess. It maps each stack at the virtual address generated by KSTACK, which leaves room for the invalid stack-guard pages. kvmmap adds the mapping PTEs to the kernel page table, and the call to kvminithart reloads the kernel page table into satp so that the hardware knows about the new PTEs.</p>
<p>Each RISC-V CPU caches page table entries in a <em>Translation Look-aside Buffer (TLB)</em>, and when xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLB entries. If it didn’t, then at some point later the TLB might use an old cached mapping, pointing to a physical page that in the meantime has been allocated to another process, and as a result, a process might be able to scribble on some other process’s memory. The RISC-V has an instruction sfence.vma that flushes the current CPU’s TLB. xv6 executes sfence.vma in kvminithart after reloading the satp register, and in the trampoline code that switches to a user page table before returning to user space <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S#L79">(kernel/trampoline.S:79)</a>.</p>
<p><strong>3.4</strong>     <strong>Physical memory allocation</strong></p>
<p>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers.</p>
<p>xv6 uses the physical memory between the end of the kernel and PHYSTOP for run-time alloca- tion. It allocates and frees whole 4096-byte pages at a time. It keeps track of which pages are free by threading a linked list through the pages themselves. Allocation consists of removing a page from the linked list; freeing consists of adding the freed page to the list.</p>
<p><strong>3.5</strong>     <strong>Code: Physical memory allocator</strong></p>
<p>The allocator resides in kalloc.c <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L1">(kernel/kalloc.c:1)</a>. The allocator’s data structure is a <em>free list</em> of physical memory pages that are available for allocation. Each free page’s list element is a struct run <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L17">(kernel/kalloc.c:17)</a>. Where does the allocator get the memory to hold that data struc- ture? It store each free page’s run structure in the free page itself, since there’s nothing else stored there. The free list is protected by a spin lock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L21-L24">(kernel/kalloc.c:21-24)</a>. The list and the lock are</p>
<p>wrapped in a struct to make clear that the lock protects the fields in the struct. For now, ignore the lock and the calls to acquire and release; Chapter 6 will examine locking in detail.</p>
<p>The function main calls kinit to initialize the allocator <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L27">(kernel/kalloc.c:27)</a>. kinit initializes the free list to hold every page between the end of the kernel and PHYSTOP. xv6 ought to de- termine how much physical memory is available by parsing configuration information provided by the hardware. Instead xv6 assumes that the machine has 128 megabytes of RAM. kinit calls freerange to add memory to the free list via per-page calls to kfree. A PTE can only refer to a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so freerange uses PGROUNDUP to ensure that it frees only aligned physical addresses. The allocator starts with no memory; these calls to kfree give it some to manage.</p>
<p>The allocator sometimes treats addresses as integers in order to perform arithmetic on them (e.g., traversing all pages in freerange), and sometimes uses addresses as pointers to read and write memory (e.g., manipulating the run structure stored in each page); this dual use of addresses is the main reason that the allocator code is full of C type casts. The other reason is that freeing and allocation inherently change the type of the memory.</p>
<p>The function kfree <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L47">(kernel/kalloc.c:47) </a>begins by setting every byte in the memory being freed to the value 1. This will cause code that uses memory after freeing it (uses “dangling references”) to read garbage instead of the old valid contents; hopefully that will cause such code to break faster. Then kfree prepends the page to the free list: it casts pa to a pointer to struct run, records the old start of the free list in r-&gt;next, and sets the free list equal to r. kalloc removes and returns the first element in the free list.</p>
<p><strong>3.6</strong>     <strong>Process address space</strong></p>
<p>Each process has a separate page table, and when xv6 switches between processes, it also changes page tables. As Figure 2.3 shows, a process’s user memory starts at virtual address zero and can grow up to MAXVA <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h#L348">(kernel/riscv.h:348)</a>, allowing a process to address in principle 256 Gigabytes of memory.</p>
<p>When a process asks xv6 for more user memory, xv6 first uses kalloc to allocate physical pages. It then adds PTEs to the process’s page table that point to the new physical pages. Xv6 sets the PTE_W, PTE_X, PTE_R, PTE_U, and PTE_V flags in these PTEs. Most processes do not use the entire user address space; xv6 leaves PTE_V clear in unused PTEs.</p>
<p>We see here a few nice examples of use of page tables. First, different processes’ page tables translate user addresses to different pages of physical memory, so that each process has private user memory. Second, each process sees its memory as having contiguous virtual addresses starting at zero, while the process’s physical memory can be non-contiguous. Third, the kernel maps a page with trampoline code at the top of the user address space, thus a single page of physical memory shows up in all address spaces.</p>
<p>Figure 3.4 shows the layout of the user memory of an executing process in xv6 in more de- tail. The stack is a single page, and is shown with the initial contents as created by exec. Strings containing the command-line arguments, as well as an array of pointers to them, are at the very top of the stack. Just under that are values that allow a program to start at main as if the function</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image032.gif" alt="img"><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image033.gif" alt="img"></p>
<p>​                                                     trampoline                            trapframe                                          heap                            stack                            guard page                            data                                   text                                    </p>
<p>MAXVA</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image034.gif" alt="img">PAGESIZE</p>
<p>nul-terminated string argv[argc]</p>
<p>​                                  argument 0                            …                            argument N                            0                            address of argument 0                            …                            address of      argument N                            address of address of      argument 0                            argc                            0xFFFFFFF                                   (empty)                                    </p>
<p>argv[0]</p>
<p>argv argument of main</p>
<p>argc argument of main return PC for main</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image032.gif" alt="img"><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image035.gif" alt="img">0</p>
<p>Figure 3.4: A process’s user address space, with its initial stack.</p>
<p>main(argc, argv) had just been called.</p>
<p>To detect a user stack overflowing the allocated stack memory, xv6 places an invalid guard page right below the stack. If the user stack overflows and the process tries to use an address below the stack, the hardware will generate a page-fault exception because the mapping is not valid. A real-world operating system might instead automatically allocate more memory for the user stack when it overflows.</p>
<p><strong>3.7</strong>     <strong>Code: sbrk</strong></p>
<p>Sbrk is the system call for a process to shrink or grow its memory. The system call is implemented by the function growproc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L239">(kernel/proc.c:239)</a>. growproc calls uvmalloc or uvmdealloc, de- pending on whether n is postive or negative. uvmalloc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L229">(kernel/vm.c:229) </a>allocates physical mem- ory with kalloc, and adds PTEs to the user page table with mappages. uvmdealloc calls uvmunmap <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L174">(kernel/vm.c:174)</a>, which uses walk to find PTEs and kfree to free the physical memory they refer to.</p>
<p>xv6 uses a process’s page table not just to tell the hardware how to map user virtual addresses, but also as the only record of which physical memory pages are allocated to that process. That is the reason why freeing user memory (in uvmunmap) requires examination of the user page table.</p>
<p><strong>3.8</strong>     <strong>Code: exec</strong></p>
<p>Exec is the system call that creates the user part of an address space. It initializes the user part of an address space from a file stored in the file system. Exec <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/exec.c#L13">(kernel/exec.c:13) </a>opens the named binary path using namei <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/exec.c#L26">(kernel/exec.c:26)</a>, which is explained in Chapter 8. Then, it reads the ELF header. Xv6 applications are described in the widely-used <em>ELF format</em>, defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/elf.h">(kernel/elf.h)</a>. An ELF binary consists of an ELF header, struct elfhdr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/elf.h#L6">(kernel/elf.h:6)</a>, followed by a sequence of program section headers, struct proghdr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/elf.h#L25">(kernel/elf.h:25)</a>. Each proghdr describes a section of the application that must be loaded into memory; xv6 programs have only one program section header, but other systems might have separate sections for instructions and data.</p>
<p>The first step is a quick check that the file probably contains an ELF binary. An ELF binary starts with the four-byte “magic number” 0x7F, ‘E’, ‘L’, ‘F’, or ELF_MAGIC <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/elf.h#L3">(kernel/elf.h:3)</a>. If the ELF header has the right magic number, exec assumes that the binary is well-formed.</p>
<p>Exec allocates a new page table with no user mappings with proc_pagetable <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/exec.c#L38">(kernel/exec.c:38)</a>, allocates memory for each ELF segment with uvmalloc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/exec.c#L52">(kernel/exec.c:52)</a>, and loads each segment into memory with loadseg <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/exec.c#L10">(kernel/exec.c:10)</a>. loadseg uses walkaddr to find the physical ad- dress of the allocated memory at which to write each page of the ELF segment, and readi to read from the file.</p>
<p>The program section header for /init, the first user program created with exec, looks like this:</p>
<p># objdump -p _init</p>
<p>user/_init:   file format elf64-littleriscv</p>
<p>Program Header:</p>
<p>LOAD off  0x00000000000000b0 vaddr 0x0000000000000000</p>
<p>paddr 0x0000000000000000 align 2**3 filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx</p>
<p>STACK off  0x0000000000000000 vaddr 0x0000000000000000</p>
<p>paddr 0x0000000000000000 align 2**4 filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-</p>
<p>The program section header’s filesz may be less than the memsz, indicating that the gap between them should be filled with zeroes (for C global variables) rather than read from the file. For /init, filesz is 2112 bytes and memsz is 2136 bytes, and thus uvmalloc allocates enough physical memory to hold 2136 bytes, but reads only 2112 bytes from the file /init.</p>
<p>Now exec allocates and initializes the user stack. It allocates just one stack page. Exec copies the argument strings to the top of the stack one at a time, recording the pointers to them in ustack. It places a null pointer at the end of what will be the argv list passed to main. The first three entries in ustack are the fake return program counter, argc, and argv pointer.</p>
<p>Exec places an inaccessible page just below the stack page, so that programs that try to use more than one page will fault. This inaccessible page also allows exec to deal with arguments that are too large; in that situation, the copyout <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L355">(kernel/vm.c:355) </a>function that exec uses to copy arguments to the stack will notice that the destination page is not accessible, and will return -1.</p>
<p>During the preparation of the new memory image, if exec detects an error like an invalid program segment, it jumps to the label bad, frees the new image, and returns -1. Exec must wait</p>
<p>to free the old image until it is sure that the system call will succeed: if the old image is gone, the system call cannot return -1 to it. The only error cases in exec happen during the creation of the image. Once the image is complete, exec can commit to the new page table <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/exec.c#L113">(kernel/exec.c:113) </a>and free the old one <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/exec.c#L117">(kernel/exec.c:117)</a>.</p>
<p>Exec loads bytes from the ELF file into memory at addresses specified by the ELF file. Users or processes can place whatever addresses they want into an ELF file. Thus exec is risky, because the addresses in the ELF file may refer to the kernel, accidentally or on purpose. The consequences for an unwary kernel could range from a crash to a malicious subversion of the kernel’s isolation mechanisms (i.e., a security exploit). xv6 performs a number of checks to avoid these risks. For example if(ph.vaddr + ph.memsz &lt; ph.vaddr) checks for whether the sum overflows a 64-bit integer. The danger is that a user could construct an ELF binary with a ph.vaddr that points to a user-chosen address, and ph.memsz large enough that the sum overflows to 0x1000, which will look like a valid value. In an older version of xv6 in which the user address space also contained the kernel (but not readable/writable in user mode), the user could choose an address that corresponded to kernel memory and would thus copy data from the ELF binary into the kernel. In the RISC-V version of xv6 this cannot happen, because the kernel has its own separate page table; loadseg loads into the process’s page table, not in the kernel’s page table.</p>
<p>It is easy for a kernel developer to omit a crucial check, and real-world kernels have a long</p>
<p>history of missing checks whose absence can be exploited by user programs to obtain kernel priv- ileges. It is likely that xv6 doesn’t do a complete job of validating user-level data supplied to the kernel, which a malicious user program might be able to exploit to circumvent xv6’s isolation.</p>
<p><strong>3.9</strong>     <strong>Real world</strong></p>
<p>Like most operating systems, xv6 uses the paging hardware for memory protection and mapping. Most operating systems make far more sophisticated use of paging than xv6 by combining paging and page-fault exceptions, which we will discuss in Chapter 4.</p>
<p>Xv6 is simplified by the kernel’s use of a direct map between virtual and physical addresses, and by its assumption that there is physical RAM at address 0x8000000, where the kernel expects to be loaded. This works with QEMU, but on real hardware it turns out to be a bad idea; real hardware places RAM and devices at unpredictable physical addresses, so that (for example) there might be no RAM at 0x8000000, where xv6 expect to be able to store the kernel. More serious kernel designs exploit the page table to turn arbitrary hardware physical memory layouts into predictable kernel virtual address layouts.</p>
<p>RISC-V supports protection at the level of physical addresses, but xv6 doesn’t use that feature. On machines with lots of memory it might make sense to use RISC-V’s support for “super pages.” Small pages make sense when physical memory is small, to allow allocation and page-out to disk with fine granularity. For example, if a program uses only 8 kilobytes of memory, giving it a whole 4-megabyte super-page of physical memory is wasteful. Larger pages make sense on</p>
<p>machines with lots of RAM, and may reduce overhead for page-table manipulation.</p>
<p>The xv6 kernel’s lack of a malloc-like allocator that can provide memory for small objects prevents the kernel from using sophisticated data structures that would require dynamic allocation.</p>
<p>Memory allocation is a perennial hot topic, the basic problems being efficient use of limited memory and preparing for unknown future requests [7]. Today people care more about speed than space efficiency. In addition, a more elaborate kernel would likely allocate many different sizes of small blocks, rather than (as in xv6) just 4096-byte blocks; a real kernel allocator would need to handle small allocations as well as large ones.</p>
<p><strong>3.10</strong>     <strong>Exercises</strong></p>
<p>\1.   Parse RISC-V’s device tree to find the amount of physical memory the computer has.</p>
<p>\2.   Write a user program that grows its address space by one byte by calling sbrk(1). Run the program and investigate the page table for the program before the call to sbrk and after the call to sbrk. How much space has the kernel allocated? What does the PTE for the new memory contain?</p>
<p>\3.   Modify xv6 to use super pages for the kernel.</p>
<p>\4.   Modify xv6 so that when a user program dereferences a null pointer, it will receive an ex- ception. That is, modify xv6 so that virtual address 0 isn’t mapped for user programs.</p>
<p>\5.   Unix implementations of exec traditionally include special handling for shell scripts. If the file to execute begins with the text #!, then the first line is taken to be a program to run to interpret the file. For example, if exec is called to run myprog arg1 and myprog ’s first line is #!/interp, then exec runs /interp with command line /interp myprog arg1. Implement support for this convention in xv6.</p>
<p>\6.   Implement address space randomization for the kernel.</p>
<p><strong>Chapter 4</strong></p>
<p><strong>Traps and system calls</strong></p>
<p>There are three kinds of event which cause the CPU to set aside ordinary execution of instructions and force a transfer of control to special code that handles the event. One situation is a system call, when a user program executes the ecall instruction to ask the kernel to do something for it. Another situation is an <em>exception</em>: an instruction (user or kernel) does something illegal, such as divide by zero or use an invalid virtual address. The third situation is a device <em>interrupt</em>, when a device signals that it needs attention, for example when the disk hardware finishes a read or write request.</p>
<p>This book uses <em>trap</em> as a generic term for these situations. Typically whatever code was execut- ing at the time of the trap will later need to resume, and shouldn’t need to be aware that anything special happened. That is, we often want traps to be transparent; this is particularly important  for interrupts, which the interrupted code typically doesn’t expect. The usual sequence is that a trap forces a transfer of control into the kernel; the kernel saves registers and other state so that execution can be resumed; the kernel executes appropriate handler code (e.g., a system call imple- mentation or device driver); the kernel restores the saved state and returns from the trap; and the original code resumes where it left off.</p>
<p>The xv6 kernel handles all traps. This is natural for system calls. It makes sense for interrupts since isolation demands that user processes not directly use devices, and because only the kernel has the state needed for device handling. It also makes sense for exceptions since xv6 responds to all exceptions from user space by killing the offending program.</p>
<p>Xv6 trap handling proceeds in four stages: hardware actions taken by the RISC-V CPU, an assembly “vector” that prepares the way for kernel C code, a C trap handler that decides what to do with the trap, and the system call or device-driver service routine. While commonality among the three trap types suggests that a kernel could handle all traps with a single code path, it turns out to be convenient to have separate assembly vectors and C trap handlers for three distinct cases: traps from user space, traps from kernel space, and timer interrupts.</p>
<p><strong>4.1</strong>     <strong>RISC-V trap machinery</strong></p>
<p>Each RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps, and that the kernel can read to find out about a trap that has occured. The RISC-V documents contain the full story [1]. riscv.h <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h#L1">(kernel/riscv.h:1) </a>contains definitions that xv6 uses. Here’s an outline of the most important registers:</p>
<p>•   stvec: The kernel writes the address of its trap handler here; the RISC-V jumps here to handle a trap.</p>
<p>•   sepc: When a trap occurs, RISC-V saves the program counter here (since the pc is then overwritten with stvec). The sret (return from trap) instruction copies sepc to the pc. The kernel can write to sepc to control where sret goes.</p>
<p>•   scause: The RISC-V puts a number here that describes the reason for the trap.</p>
<p>•   sscratch: The kernel places a value here that comes in handy at the very start of a trap handler.</p>
<p>•   sstatus: The SIE bit in sstatus controls whether device interrupts are enabled. If the kernel clears SIE, the RISC-V will defer device interrupts until the kernel sets SIE. The SPP bit indicates whether a trap came from user mode or supervisor mode, and controls to what mode sret returns.</p>
<p>The above registers relate to traps handled in supervisor mode, and they cannot be read or written in user mode. There is an equivalent set of control registers for traps handled in machine mode; xv6 uses them only for the special case of timer interrupts.</p>
<p>Each CPU on a multi-core chip has its own set of these registers, and more than one CPU may be handling a trap at any given time.</p>
<p>When it needs to force a trap, the RISC-V hardware does the following for all trap types (other than timer interrupts):</p>
<p>\1.   If the trap is a device interrupt, and the sstatus SIE bit is clear, don’t do any of the following.</p>
<p>\2.   Disable interrupts by clearing SIE.</p>
<p>\3.   Copy the pc to sepc.</p>
<p>\4.   Save the current mode (user or supervisor) in the SPP bit in sstatus.</p>
<p>\5.   Set scause to reflect the trap’s cause.</p>
<p>\6.   Set the mode to supervisor.</p>
<p>\7.   Copy stvec to the pc.</p>
<p>\8.   Start executing at the new pc.</p>
<p>Note that the CPU doesn’t switch to the kernel page table, doesn’t switch to a stack in the kernel, and doesn’t save any registers other than the pc. Kernel software must perform these tasks. One reason that the CPU does minimal work during a trap is to provide flexibility to software; for example, some operating systems don’t require a page table switch in some situations, which can increase performance.</p>
<p>You might wonder whether the CPU hardware’s trap handling sequence could be further simpli- fied. For example, suppose that the CPU didn’t switch program counters. Then a trap could switch to supervisor mode while still running user instructions. Those user instructions could break the user/kernel isolation, for example by modifying the satp register to point to a page table that allowed accessing all of physical memory. It is thus important that the CPU switch to a kernel- specified instruction address, namely stvec.</p>
<p><strong>4.2</strong>     <strong>Traps</strong> <strong>from user space</strong></p>
<p>A trap may occur while executing in user space if the user program makes a system call (ecall instruction), or does something illegal, or if a device interrupts. The high-level path of a trap from user space is uservec <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S#L16">(kernel/trampoline.S:16)</a>, then usertrap <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L37">(kernel/trap.c:37)</a>; and when re- turning, usertrapret <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L90">(kernel/trap.c:90) </a>and then userret <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S#L16">(kernel/trampoline.S:16)</a>.</p>
<p>Traps from user code are more challenging than from the kernel, since satp points to a user page table that doesn’t map the kernel, and the stack pointer may contain an invalid or even mali- cious value.</p>
<p>Because the RISC-V hardware doesn’t switch page tables during a trap, the user page table must include a mapping for uservec, the trap vector instructions that stvec points to. uservec must switch satp to point to the kernel page table; in order to continue executing instructions after the switch, uservec must be mapped at the same address in the kernel page table as in the user page table.</p>
<p>Xv6 satisfies these constraints with a <em>trampoline</em> page that contains uservec. Xv6 maps the trampoline page at the same virtual address in the kernel page table and in every user page table. This virtual address is TRAMPOLINE (as we saw in Figure 2.3 and in Figure 3.3). The trampoline contents are set in trampoline.S, and (when executing user code) stvec is set to uservec <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S#L16">(kernel/trampoline.S:16)</a>.</p>
<p>When uservec starts, all 32 registers contain values owned by the interrupted code. But uservec needs to be able to modify some registers in order to set satp and generate addresses at which to save the registers. RISC-V provides a helping hand in the form of the sscratch register. The csrrw instruction at the start of uservec swaps the contents of a0 and sscratch. Now the user code’s a0 is saved; uservec has one register (a0) to play with; and a0 contains the value the kernel previously placed in sscratch.</p>
<p>uservec’s next task is to save the user registers. Before entering user space, the kernel previously set sscratch to point to a per-process trapframe that (among other things) has space to save all the user registers <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.h#L44">(kernel/proc.h:44)</a>. Because satp still refers to the user page</p>
<p>table, uservec needs the trapframe to be mapped in the user address space. When creating each process, xv6 allocates a page for the process’s trapframe, and arranges for it always to be mapped at user virtual address TRAPFRAME, which is just below TRAMPOLINE. The process’s p-&gt;trapframe also points to the trapframe, though at its physical address so the kernel can use it through the kernel page table.</p>
<p>Thus after swapping a0 and sscratch, a0 holds a pointer to the current process’s trapframe.</p>
<p>uservec now saves all user registers there, including the user’s a0, read from sscratch.</p>
<p>The trapframe contains pointers to the current process’s kernel stack, the current CPU’s hartid, the address of usertrap, and the address of the kernel page table. uservec retrieves these values, switches satp to the kernel page table, and calls usertrap.</p>
<p>The job of usertrap is to determine the cause of the trap, process it, and return <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L37">(kernel/-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L37">trap.c:37)</a>. As mentioned above, it first changes stvec so that a trap while in the kernel will be handled by kernelvec. It saves the sepc (the saved user program counter), again because there might be a process switch in usertrap that could cause sepc to be overwritten. If the trap is a system call, syscall handles it; if a device interrupt, devintr; otherwise it’s an exception, and the kernel kills the faulting process. The system call path adds four to the saved user pc because RISC-V, in the case of a system call, leaves the program pointer pointing to the ecall instruction. On the way out, usertrap checks if the process has been killed or should yield the CPU (if this trap is a timer interrupt).</p>
<p>The first step in returning to user space is the call to usertrapret <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L90">(kernel/trap.c:90)</a>. This function sets up the RISC-V control registers to prepare for a future trap from user space. This in- volves changing stvec to refer to uservec, preparing the trapframe fields that uservec relies on, and setting sepc to the previously saved user program counter. At the end, usertrapret calls userret on the trampoline page that is mapped in both user and kernel page tables; the reason is that assembly code in userret will switch page tables.</p>
<p>usertrapret’s call to userret passes a pointer to the process’s user page table in a0 and TRAPFRAME in a1 <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S#L88">(kernel/trampoline.S:88)</a>. userret switches satp to the process’s user page table. Recall that the user page table maps both the trampoline page and TRAPFRAME, but nothing else from the kernel. Again, the fact that the trampoline page is mapped at the same virtual address in user and kernel page tables is what allows uservec to keep executing after changing satp. userret copies the trapframe’s saved user a0 to sscratch in preparation for a later swap with TRAPFRAME. From this point on, the only data userret can use is the register contents and the content of the trapframe. Next userret restores saved user registers from the trapframe, does a final swap of a0 and sscratch to restore the user a0 and save TRAPFRAME for the next trap, and uses sret to return to user space.</p>
<h1 id="4-3-Code-Calling-system-calls"><a href="#4-3-Code-Calling-system-calls" class="headerlink" title="4.3     Code: Calling system calls"></a>4.3     Code: Calling system calls</h1><p>Chapter 2 ended with initcode.S invoking the exec system call <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/initcode.S#L11">(user/initcode.S:11)</a>. Let’s look at how the user call makes its way to the exec system call’s implementation in the kernel.</p>
<p>The user code places the arguments for exec in registers a0 and a1, and puts the system call number in a7. System call numbers match the entries in the syscalls array, a table of function</p>
<p>pointers <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/syscall.c#L108">(kernel/syscall.c:108)</a>. The ecall instruction traps into the kernel and executes uservec,</p>
<p>usertrap, and then syscall, as we saw above.</p>
<p>syscall <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/syscall.c#L133">(kernel/syscall.c:133) </a>retrieves the system call number from the saved a7 in the trapframe and uses it to index into syscalls. For the first system call, a7 contains SYS_exec <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/syscall.h#L8">(ker-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/syscall.h#L8">nel/syscall.h:8)</a>, resulting in a call to the system call implementation function sys_exec.</p>
<p>When the system call implementation function returns, syscall records its return value in p-&gt;trapframe-&gt;a0. This will cause the original user-space call to exec() to return that value, since the C calling convention on RISC-V places return values in a0. System calls conventionally return negative numbers to indicate errors, and zero or positive numbers for success. If the system call number is invalid, syscall prints an error and returns <em>−</em>1.</p>
<h1 id="4-4-Code-System-call-arguments"><a href="#4-4-Code-System-call-arguments" class="headerlink" title="4.4     Code: System call arguments"></a>4.4     Code: System call arguments</h1><p>System call implementations in the kernel need to find the arguments passed by user code. Because user code calls system call wrapper functions, the arguments are initially where the RISC-V C calling convention places them: in registers. The kernel trap code saves user registers to the current process’s trap frame, where kernel code can find them. The functions argint, argaddr, and argfd retrieve the <em>n</em> ’th system call argument from the trap frame as an integer, pointer, or a file descriptor. They all call argraw to retrieve the appropriate saved user register <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/syscall.c#L35">(kernel/syscall.c:35)</a>.</p>
<p>Some system calls pass pointers as arguments, and the kernel must use those pointers to read or write user memory. The exec system call, for example, passes the kernel an array of pointers referring to string arguments in user space. These pointers pose two challenges. First, the user pro- gram may be buggy or malicious, and may pass the kernel an invalid pointer or a pointer intended to trick the kernel into accessing kernel memory instead of user memory. Second, the xv6 kernel page table mappings are not the same as the user page table mappings, so the kernel cannot use ordinary instructions to load or store from user-supplied addresses.</p>
<p>The kernel implements functions that safely transfer data to and from user-supplied addresses. fetchstr is an example <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/syscall.c#L25">(kernel/syscall.c:25)</a>. File system calls such as exec use fetchstr to retrieve string file-name arguments from user space. fetchstr calls copyinstr to do the hard work.</p>
<p>copyinstr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L406">(kernel/vm.c:406)</a> copies up to max bytes to dst from virtual address srcva in the user page table pagetable. It uses walkaddr (which calls walk) to walk the page table in software to determine the physical address pa0 for srcva. Since the kernel maps all physical RAM addresses to the same kernel virtual address, copyinstr can directly copy string bytes from pa0 to dst. walkaddr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L95">(kernel/vm.c:95) </a>checks that the user-supplied virtual address is part of the process’s user address space, so programs cannot trick the kernel into reading other memory. A similar function, copyout, copies data from the kernel to a user-supplied address.</p>
<h1 id="4-5-Traps-from-kernel-space"><a href="#4-5-Traps-from-kernel-space" class="headerlink" title="4.5     Traps from kernel space"></a>4.5     Traps from kernel space</h1><p>Xv6 configures the CPU trap registers somewhat differently depending on whether user or kernel code is executing. When the kernel is executing on a CPU, the kernel points stvec to the assembly code at kernelvec <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kernelvec.S#L10">(kernel/kernelvec.S:10)</a>. Since xv6 is already in the kernel, kernelvec can rely on satp being set to the kernel page table, and on the stack pointer referring to a valid kernel stack. kernelvec saves all registers so that the interrupted code can eventually resume without disturbance.</p>
<p>kernelvec saves the registers on the stack of the interrupted kernel thread, which makes sense because the register values belong to that thread. This is particularly important if the trap causes a switch to a different thread – in that case the trap will actually return on the stack of the new thread, leaving the interrupted thread’s saved registers safely on its stack.</p>
<p>kernelvec jumps to kerneltrap <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L134">(kernel/trap.c:134) </a>after saving registers. kerneltrap is prepared for two types of traps: device interrrupts and exceptions. It calls devintr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L177">(kernel/-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L177">trap.c:177)</a> to check for and handle the former. If the trap isn’t a device interrupt, it must be an exception, and that is always a fatal error if it occurs in the xv6 kernel; the kernel calls panic and stops executing.</p>
<p>If kerneltrap was called due to a timer interrupt, and a process’s kernel thread is running (rather than a scheduler thread), kerneltrap calls yield to give other threads a chance to run. At some point one of those threads will yield, and let our thread and its kerneltrap resume again. Chapter 7 explains what happens in yield.</p>
<p>When kerneltrap’s work is done, it needs to return to whatever code was interrupted by the trap. Because a yield may have disturbed the saved sepc and the saved previous mode in sstatus, kerneltrap saves them when it starts. It now restores those control registers and returns to kernelvec <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kernelvec.S#L48">(kernel/kernelvec.S:48)</a>. kernelvec pops the saved registers from the stack and executes sret, which copies sepc to pc and resumes the interrupted kernel code.</p>
<p>It’s worth thinking through how the trap return happens if kerneltrap called yield due to a timer interrupt.</p>
<p>Xv6 sets a CPU’s stvec to kernelvec when that CPU enters the kernel from user space; you can see this in usertrap <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L29">(kernel/trap.c:29)</a>. There’s a window of time when the kernel is executing but stvec is set to uservec, and it’s crucial that device interrupts be disabled during that window. Luckily the RISC-V always disables interrupts when it starts to take a trap, and xv6 doesn’t enable them again until after it sets stvec.</p>
<h1 id="4-6-Page-fault-exceptions"><a href="#4-6-Page-fault-exceptions" class="headerlink" title="4.6     Page-fault exceptions"></a>4.6     Page-fault exceptions</h1><p>Xv6’s response to exceptions is quite boring: if an exception happens in user space, the kernel kills the faulting process. If an exception happens in the kernel, the kernel panics. Real operating systems often respond in much more interesting ways.</p>
<p>As an example, many kernels use page faults to implement <em>copy-on-write (COW) fork</em>. To explain copy-on-write fork, consider xv6’s fork, described in Chapter 3. fork causes the child to have the same memory content as the parent, by calling uvmcopy <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/vm.c#L309">(kernel/vm.c:309) </a>to allocate</p>
<p>physical memory for the child and copy the parent’s memory into it. It would be more efficient if the child and parent could share the parent’s physical memory. A straightforward implementation of this would not work, however, since it would cause the parent and child to disrupt each other’s execution with their writes to the shared stack and heap.</p>
<p>Parent and child can safely share phyical memory using copy-on-write fork, driven by page faults. When a CPU cannot translate a virtual address to a physical address, the CPU generates  a <em>page-fault exception</em>. RISC-V has three different kinds of page fault: load page faults (when a load instruction cannot translate its virtual address), store page faults (when a store instruction cannot translate its virtual address), and instruction page faults (when the address for an instruction doesn’t translate). The value in the scause register indicates the type of the page fault and the stval register contains the address that couldn’t be translated.</p>
<p>The basic plan in COW fork is for the parent and child to initially share all physical pages, but to map them read-only. Thus, when the child or parent executes a store instruction, the RISC-V CPU raises a page-fault exception. In response to this exception, the kernel makes a copy of the page that contains the faulted address. It maps one copy read/write in the child’s address space and the other copy read/write in the parent’s address space. After updating the page tables, the kernel resumes the faulting process at the instruction that caused the fault. Because the kernel has updated the relevant PTE to allow writes, the faulting instruction will now execute without a fault.</p>
<p>This COW plan works well for fork, because often the child calls exec immediately after the fork, replacing its address space with a new address space. In that common case, the child will experience only a few page faults, and the kernel can avoid making a complete copy. Furthermore, COW fork is transparent: no modifications to applications are necessary for them to benefit.</p>
<p>The combination of page tables and page faults opens up a wide-range of interesting possibil- ities other than COW fork. Another widely-used feature is called <em>lazy allocation</em>, which has two parts. First, when an application calls sbrk, the kernel grows the address space, but marks the new addresses as not valid in the page table. Second, on a page fault on one of those new addresses, the kernel allocates physical memory and maps it into the page table. Since applications often ask for more memory than they need, lazy allocation is a win: the kernel allocates memory only when the application actually uses it. Like COW fork, the kernel can implement this feature transparently to applications.</p>
<p>Yet another widely-used feature that exploits page faults is <em>paging from disk</em>. If applications need more memory than the available physical RAM, the kernel can evict some pages: write them to a storage device such as a disk and mark their PTEs as not valid. If an application reads or writes an evicted page, the CPU will experience a page fault. The kernel can then inspect the faulting address. If the address belongs to a page that is on disk, the kernel allocates a page of physical memory, reads the page from disk to that memory, updates the PTE to be valid and refer to that memory, and resumes the application. To make room for the page, the kernel may have to evict another page. This feature requires no changes to applications, and works well if applications have locality of reference (i.e., they use only a subset of their memory at any given time).</p>
<p>Other features that combine paging and page-fault exceptions include automatically extending stacks and memory-mapped files.</p>
<h1 id="4-7-Real-world"><a href="#4-7-Real-world" class="headerlink" title="4.7     Real world"></a>4.7     Real world</h1><p>The need for special trampoline pages could be eliminated if kernel memory were mapped into ev- ery process’s user page table (with appropriate PTE permission flags). That would also eliminate the need for a page table switch when trapping from user space into the kernel. That in turn would allow system call implementations in the kernel to take advantage of the current process’s user memory being mapped, allowing kernel code to directly dereference user pointers. Many operat- ing systems have used these ideas to increase efficiency. Xv6 avoids them in order to reduce the chances of security bugs in the kernel due to inadvertent use of user pointers, and to reduce some complexity that would be required to ensure that user and kernel virtual addresses don’t overlap.</p>
<h1 id="4-8-Exercises"><a href="#4-8-Exercises" class="headerlink" title="4.8     Exercises"></a>4.8     Exercises</h1><p>\1.   The functions copyin and copyinstr walk the user page table in software. Set up the kernel page table so that the kernel has the user program mapped, and copyin and copyinstr can use memcpy to copy system call arguments into kernel space, relying on the hardware to do the page table walk.</p>
<p>\2.   Implement lazy memory allocation</p>
<p>\3.   Implement COW fork</p>
<p><strong>Chapter 5</strong></p>
<p><strong>Interrupts and device drivers</strong></p>
<p>A <em>driver</em> is the code in an operating system that manages a particular device: it configures the device hardware, tells the device to perform operations, handles the resulting interrupts, and interacts with processes that may be waiting for I/O from the device. Driver code can be tricky because a driver executes concurrently with the device that it manages. In addition, the driver must understand the device’s hardware interface, which can be complex and poorly documented.</p>
<p>Devices that need attention from the operating system can usually be configured to generate interrupts, which are one type of trap. The kernel trap handling code recognizes when a device has raised an interrupt and calls the driver’s interrupt handler; in xv6, this dispatch happens in devintr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L177">(kernel/trap.c:177)</a>.</p>
<p>Many device drivers execute code in two contexts: a <em>top half</em> that runs in a process’s kernel thread, and a <em>bottom half</em> that executes at interrupt time. The top half is called via system calls such as read and write that want the device to perform I/O. This code may ask the hardware to start an operation (e.g., ask the disk to read a block); then the code waits for the operation   to complete. Eventually the device completes the operation and raises an interrupt. The driver’s interrupt handler, acting as the bottom half, figures out what operation has completed, wakes up a waiting process if appropriate, and tells the hardware to start work on any waiting next operation.</p>
<h1 id="5-1-Code-Console-input"><a href="#5-1-Code-Console-input" class="headerlink" title="5.1     Code: Console input"></a>5.1     Code: Console input</h1><p>The console driver <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/console.c">(console.c) </a>is a simple illustration of driver structure. The console driver accepts characters typed by a human, via the <em>UART</em> serial-port hardware attached to the RISC-V. The console driver accumulates a line of input at a time, processing special input characters such as backspace and control-u. User processes, such as the shell, use the read system call to fetch lines of input from the console. When you type input to xv6 in QEMU, your keystrokes are delivered to xv6 by way of QEMU’s simulated UART hardware.</p>
<p>The UART hardware that the driver talks to is a 16550 chip [11] emulated by QEMU. On a real computer, a 16550 would manage an RS232 serial link connecting to a terminal or other computer. When running QEMU, it’s connected to your keyboard and display.</p>
<p>The UART hardware appears to software as a set of <em>memory-mapped</em> control registers. That</p>
<p>is, there are some physical addresses that RISC-V hardware connects to the UART device, so that loads and stores interact with the device hardware rather than RAM. The memory-mapped ad- dresses for the UART start at 0x10000000, or UART0 <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/memlayout.h#L21">(kernel/memlayout.h:21)</a>. There are a handful of UART control registers, each the width of a byte. Their offsets from UART0 are defined in <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/uart.c#L22">(kernel/uart.c:22)</a>. For example, the LSR register contain bits that indicate whether input characters are waiting to be read by the software. These characters (if any) are available for reading from the RHR register. Each time one is read, the UART hardware deletes it from an internal FIFO of waiting characters, and clears the “ready” bit in LSR when the FIFO is empty. The UART transmit hardware is largely independent of the receive hardware; if software writes a byte to the THR, the UART transmit that byte.</p>
<p>Xv6’s main calls consoleinit <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/console.c#L184">(kernel/console.c:184) </a>to initialize the UART hardware. This code configures the UART to generate a receive interrupt when the UART receives each byte of input, and a <em>transmit complete</em> interrupt each time the UART finishes sending a byte of output <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/uart.c#L53">(kernel/uart.c:53)</a>.</p>
<p>The xv6 shell reads from the console by way of a file descriptor opened by init.c <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/init.c#L19">(user/init.c:19)</a>.</p>
<p>Calls to the read system call make their way through the kernel to consoleread <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/console.c#L82">(kernel/con-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/console.c#L82">sole.c:82)</a>. consoleread waits for input to arrive (via interrupts) and be buffered in cons.buf, copies the input to user space, and (after a whole line has arrived) returns to the user process. If the user hasn’t typed a full line yet, any reading processes will wait in the sleep call <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/console.c#L98">(kernel/con-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/console.c#L98">sole.c:98) </a>(Chapter 7 explains the details of sleep).</p>
<p>When the user types a character, the UART hardware asks the RISC-V to raise an interrupt, which activates xv6’s trap handler. The trap handler calls devintr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L177">(kernel/trap.c:177)</a>, which looks at the RISC-V scause register to discover that the interrupt is from an external device. Then it asks a hardware unit called the PLIC [1] to tell it which device interrupted <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L186">(kernel/trap.c:186)</a>. If it was the UART, devintr calls uartintr.</p>
<p>uartintr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/uart.c#L180">(kernel/uart.c:180) </a>reads any waiting input characters from the UART hardware and hands them to consoleintr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/console.c#L138">(kernel/console.c:138)</a>; it doesn’t wait for characters, since future input will raise a new interrupt. The job of consoleintr is to accumulate input characters in cons.buf until a whole line arrives. consoleintr treats backspace and a few other characters specially. When a newline arrives, consoleintr wakes up a waiting consoleread (if there is one).</p>
<p>Once woken, consoleread will observe a full line in cons.buf, copy it to user space, and return (via the system call machinery) to user space.</p>
<h1 id="5-2-Code-Console-output"><a href="#5-2-Code-Console-output" class="headerlink" title="5.2     Code: Console output"></a>5.2     Code: Console output</h1><p>A write system call on a file descriptor connected to the console eventually arrives at uartputc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/uart.c#L87">(kernel/uart.c:87)</a>. The device driver maintains an output buffer (uart_tx_buf) so that writing processes do not have to wait for the UART to finish sending; instead, uartputc appends each character to the buffer, calls uartstart to start the device transmitting (if it isn’t already), and returns. The only situation in which uartputc waits is if the buffer is already full.</p>
<p>Each time the UART finishes sending a byte, it generates an interrupt. uartintr calls uartstart,</p>
<p>which checks that the device really has finished sending, and hands the device the next buffered output character. Thus if a process writes multiple bytes to the console, typically the first byte will be sent by uartputc’s call to uartstart, and the remaining buffered bytes will be sent by uartstart calls from uartintr as transmit complete interrupts arrive.</p>
<p>A general pattern to note is the decoupling of device activity from process activity via buffering and interrupts. The console driver can process input even when no process is waiting to read it; a subsequent read will see the input. Similarly, processes can send output without having to wait for the device. This decoupling can increase performance by allowing processes to execute concur- rently with device I/O, and is particularly important when the device is slow (as with the UART) or needs immediate attention (as with echoing typed characters). This idea is sometimes called <em>I/O concurrency</em>.</p>
<h1 id="5-3-Concurrency-in-drivers"><a href="#5-3-Concurrency-in-drivers" class="headerlink" title="5.3     Concurrency in drivers"></a>5.3     Concurrency in drivers</h1><p>You may have noticed calls to acquire in consoleread and in consoleintr. These calls acquire a lock, which protects the console driver’s data structures from concurrent access. There are three concurrency dangers here: two processes on different CPUs might call consoleread at the same time; the hardware might ask a CPU to deliver a console (really UART) interrupt while that CPU is already executing inside consoleread; and the hardware might deliver a console interrupt on a different CPU while consoleread is executing. Chapter 6 explores how locks help in these scenarios.</p>
<p>Another way in which concurrency requires care in drivers is that one process may be waiting for input from a device, but the interrupt signaling arrival of the input may arrive when a different process (or no process at all) is running. Thus interrupt handlers are not allowed to think about the process or code that they have interrupted. For example, an interrupt handler cannot safely call copyout with the current process’s page table. Interrupt handlers typically do relatively little work (e.g., just copy the input data to a buffer), and wake up top-half code to do the rest.</p>
<h1 id="5-4-Timer-interrupts"><a href="#5-4-Timer-interrupts" class="headerlink" title="5.4     Timer interrupts"></a>5.4     Timer interrupts</h1><p>Xv6 uses timer interrupts to maintain its clock and to enable it to switch among compute-bound processes; the yield calls in usertrap and kerneltrap cause this switching. Timer inter- rupts come from clock hardware attached to each RISC-V CPU. Xv6 programs this clock hardware to interrupt each CPU periodically.</p>
<p>RISC-V requires that timer interrupts be taken in machine mode, not supervisor mode. RISC- V machine mode executes without paging, and with a separate set of control registers, so it’s not practical to run ordinary xv6 kernel code in machine mode. As a result, xv6 handles timer interrupts completely separately from the trap mechanism laid out above.</p>
<p>Code executed in machine mode in start.c, before main, sets up to receive timer interrupts <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/start.c#L57">(kernel/start.c:57)</a>. Part of the job is to program the CLINT hardware (core-local interruptor) to generate an interrupt after a certain delay. Another part is to set up a scratch area, analogous to the</p>
<p>trapframe, to help the timer interrupt handler save registers and the address of the CLINT registers. Finally, start sets mtvec to timervec and enables timer interrupts.</p>
<p>A timer interrupt can occur at any point when user or kernel code is executing; there’s no way</p>
<p>for the kernel to disable timer interrupts during critical operations. Thus the timer interrupt handler must do its job in a way guaranteed not to disturb interrupted kernel code. The basic strategy is for the handler to ask the RISC-V to raise a “software interrupt” and immediately return. The RISC-V delivers software interrupts to the kernel with the ordinary trap mechanism, and allows the kernel to disable them. The code to handle the software interrupt generated by a timer interrupt can be seen in devintr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L204">(kernel/trap.c:204)</a>.</p>
<p>The machine-mode timer interrupt vector is timervec <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kernelvec.S#L93">(kernel/kernelvec.S:93)</a>. It saves a few</p>
<p>registers in the scratch area prepared by start, tells the CLINT when to generate the next timer interrupt, asks the RISC-V to raise a software interrupt, restores registers, and returns. There’s no C code in the timer interrupt handler.</p>
<h1 id="5-5-Real-world"><a href="#5-5-Real-world" class="headerlink" title="5.5     Real world"></a>5.5     Real world</h1><p>Xv6 allows device and timer interrupts while executing in the kernel, as well as when executing user programs. Timer interrupts force a thread switch (a call to yield) from the timer interrupt handler, even when executing in the kernel. The ability to time-slice the CPU fairly among kernel threads is useful if kernel threads sometimes spend a lot of time computing, without returning to user space. However, the need for kernel code to be mindful that it might be suspended (due to  a timer interrupt) and later resume on a different CPU is the source of some complexity in xv6. The kernel could be made somewhat simpler if device and timer interrupts only occurred while executing user code.</p>
<p>Supporting all the devices on a typical computer in its full glory is much work, because there are many devices, the devices have many features, and the protocol between device and driver can be complex and poorly documented. In many operating systems, the drivers account for more code than the core kernel.</p>
<p>The UART driver retrieves data a byte at a time by reading the UART control registers; this pattern is called <em>programmed I/O</em>, since software is driving the data movement. Programmed I/O is simple, but too slow to be used at high data rates. Devices that need to move lots of data at high speed typically use <em>direct memory access (DMA)</em>. DMA device hardware directly writes incoming data to RAM, and reads outgoing data from RAM. Modern disk and network devices use DMA. A driver for a DMA device would prepare data in RAM, and then use a single write to a control register to tell the device to process the prepared data.</p>
<p>Interrupts make sense when a device needs attention at unpredictable times, and not too often. But interrupts have high CPU overhead. Thus high speed devices, such networks and disk con- trollers, use tricks that reduce the need for interrupts. One trick is to raise a single interrupt for a whole batch of incoming or outgoing requests. Another trick is for the driver to disable interrupts entirely, and to check the device periodically to see if it needs attention. This technique is called <em>polling</em>. Polling makes sense if the device performs operations very quickly, but it wastes CPU time if the device is mostly idle. Some drivers dynamically switch between polling and interrupts</p>
<p>depending on the current device load.</p>
<p>The UART driver copies incoming data first to a buffer in the kernel, and then to user space. This makes sense at low data rates, but such a double copy can significantly reduce performance for devices that generate or consume data very quickly. Some operating systems are able to directly move data between user-space buffers and device hardware, often with DMA.</p>
<h1 id="5-6-Exercises"><a href="#5-6-Exercises" class="headerlink" title="5.6     Exercises"></a>5.6     Exercises</h1><p>\1.   Modify uart.c to not use interrupts at all. You may need to modify console.c as well.</p>
<p>\2.   Add a driver for an Ethernet card.</p>
<p><strong>Chapter 6 Locking</strong></p>
<p>Most kernels, including xv6, interleave the execution of multiple activities. One source of inter- leaving is multiprocessor hardware: computers with multiple CPUs executing independently, such as xv6’s RISC-V. These multiple CPUs share physical RAM, and xv6 exploits the sharing to main- tain data structures that all CPUs read and write. This sharing raises the possibility of one CPU reading a data structure while another CPU is mid-way through updating it, or even multiple CPUs updating the same data simultaneously; without careful design such parallel access is likely to yield incorrect results or a broken data structure. Even on a uniprocessor, the kernel may switch the CPU among a number of threads, causing their execution to be interleaved. Finally, a device interrupt handler that modifies the same data as some interruptible code could damage the data if the interrupt occurs at just the wrong time. The word <em>concurrency</em> refers to situations in which multiple instruction streams are interleaved, due to multiprocessor parallelism, thread switching, or interrupts.</p>
<p>Kernels are full of concurrently-accessed data. For example, two CPUs could simultaneously call kalloc, thereby concurrently popping from the head of the free list. Kernel designers like to allow for lots of concurrency, since it can yield increased performance though parallelism, and increased responsiveness. However, as a result kernel designers spend a lot of effort convincing themselves of correctness despite such concurrency. There are many ways to arrive at correct code, some easier to reason about than others. Strategies aimed at correctness under concurrency, and abstractions that support them, are called <em>concurrency control</em> techniques.</p>
<p>Xv6 uses a number of concurrency control techniques, depending on the situation; many more are possible. This chapter focuses on a widely used technique: the <em>lock</em>. A lock provides mutual exclusion, ensuring that only one CPU at a time can hold the lock. If the programmer associates a lock with each shared data item, and the code always holds the associated lock when using an item, then the item will be used by only one CPU at a time. In this situation, we say that the lock pro- tects the data item. Although locks are an easy-to-understand concurrency control mechanism, the downside of locks is that they can kill performance, because they serialize concurrent operations.</p>
<p>The rest of this chapter explains why xv6 needs locks, how xv6 implements them, and how it uses them.</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image036.gif" alt="img">Memory</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image037.gif" alt="img"></td>
</tr>
</tbody></table>
<h2 id="CPU-CPU"><a href="#CPU-CPU" class="headerlink" title="CPU          CPU"></a>CPU          CPU</h2><p>Figure 6.1: Simplified SMP architecture</p>
<h1 id="6-1-Race-conditions"><a href="#6-1-Race-conditions" class="headerlink" title="6.1     Race conditions"></a>6.1     Race conditions</h1><p>As an example of why we need locks, consider two processes calling wait on two different CPUs. wait frees the child’s memory. Thus on each CPU, the kernel will call kfree to free the chil- dren’s pages. The kernel allocator maintains a linked list: kalloc() <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L69">(kernel/kalloc.c:69)</a> pops a page of memory from a list of free pages, and kfree() <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L47">(kernel/kalloc.c:47) </a>pushes a page onto the free list. For best performance, we might hope that the kfrees of the two parent processes would execute in parallel without either having to wait for the other, but this would not be correct given xv6’s kfree implementation.</p>
<p>Figure 6.1 illustrates the setting in more detail: the linked list is in memory that is shared by the two CPUs, which manipulate the linked list using load and store instructions. (In reality, the processors have caches, but conceptually multiprocessor systems behave as if there were a single, shared memory.) If there were no concurrent requests, you might implement a list push operation as follows:</p>
<p>1                struct element {</p>
<p>2                     int data;</p>
<p>3                     struct element *next;</p>
<p>4      };</p>
<p>5</p>
<p>6      struct element *list = 0;</p>
<p>7</p>
<p>8                void</p>
<p>9                push(int data)</p>
<p>10      {</p>
<p>11         struct element *l;</p>
<p>12</p>
<p>13                     l = malloc(sizeof *l);</p>
<p>14                     l-&gt;data = data;</p>
<p>15                     l-&gt;next = list;</p>
<p>16                     list = l;</p>
<p>CPU 1</p>
<p>15                   16</p>
<p>Memory</p>
<p>l-&gt;next</p>
<p>l-&gt;next</p>
<p>list</p>
<p>list</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image042.gif" alt="img">CPU2                                                 </p>
<p>15                 16</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image044.gif" alt="img"></td>
</tr>
</tbody></table>
<p>Figure 6.2: Example race</p>
<p>Time</p>
<p>17     }</p>
<p>This implementation is correct if executed in isolation. However, the code is not correct if more than one copy executes concurrently. If two CPUs execute push at the same time, both might execute line 15 as shown in Fig 6.1, before either executes line 16, which results in an incorrect outcome as illustrated by Figure 6.2. There would then be two list elements with next set to the former value of list. When the two assignments to list happen at line 16, the second one will overwrite the first; the element involved in the first assignment will be lost.</p>
<p>The lost update at line 16 is an example of a <em>race condition</em>. A race condition is a situation in which a memory location is accessed concurrently, and at least one access is a write. A race is often a sign of a bug, either a lost update (if the accesses are writes) or a read of an incompletely-updated data structure. The outcome of a race depends on the exact timing of the two CPUs involved and how their memory operations are ordered by the memory system, which can make race-induced errors difficult to reproduce and debug. For example, adding print statements while debugging push might change the timing of the execution enough to make the race disappear.</p>
<p>The usual way to avoid races is to use a lock. Locks ensure <em>mutual exclusion</em>, so that only one CPU at a time can execute the sensitive lines of push; this makes the scenario above impossible. The correctly locked version of the above code adds just a few lines (highlighted in yellow):</p>
<p>6             struct element *list = 0;</p>
<p>7             struct lock listlock;</p>
<p>8</p>
<p>9             void</p>
<p>10             push(int data)</p>
<p>11     {</p>
<p>12                  struct element *l;</p>
<p>13                  l = malloc(sizeof *l);</p>
<p>14                  l-&gt;data = data;</p>
<p>15</p>
<table>
<thead>
<tr>
<th>16</th>
<th></th>
<th>acquire(&amp;listlock);</th>
</tr>
</thead>
<tbody><tr>
<td>17</td>
<td></td>
<td>l-&gt;next = list;</td>
</tr>
<tr>
<td>18</td>
<td></td>
<td>list = l;</td>
</tr>
<tr>
<td>19</td>
<td></td>
<td>release(&amp;listlock);</td>
</tr>
<tr>
<td>20</td>
<td>}</td>
<td></td>
</tr>
</tbody></table>
<p>The sequence of instructions between acquire and release is often called a <em>critical section</em>. The lock is typically said to be protecting list.</p>
<p>When we say that a lock protects data, we really mean that the lock protects some collection of invariants that apply to the data. Invariants are properties of data structures that are maintained across operations. Typically, an operation’s correct behavior depends on the invariants being true when the operation begins. The operation may temporarily violate the invariants but must reestab- lish them before finishing. For example, in the linked list case, the invariant is that list points at the first element in the list and that each element’s next field points at the next element. The implementation of push violates this invariant temporarily: in line 17, l points to the next list ele- ment, but list does not point at l yet (reestablished at line 18). The race condition we examined above happened because a second CPU executed code that depended on the list invariants while they were (temporarily) violated. Proper use of a lock ensures that only one CPU at a time can operate on the data structure in the critical section, so that no CPU will execute a data structure operation when the data structure’s invariants do not hold.</p>
<p>You can think of a lock as <em>serializing</em> concurrent critical sections so that they run one at a time, and thus preserve invariants (assuming the critical sections are correct in isolation). You can also think of critical sections guarded by the same lock as being atomic with respect to each other,  so that each sees only the complete set of changes from earlier critical sections, and never sees partially-completed updates.</p>
<p>Although correct use of locks can make incorrect code correct, locks limit performance. For example, if two processes call kfree concurrently, the locks will serialize the two calls, and we obtain no benefit from running them on different CPUs. We say that multiple processes <em>conflict</em> if they want the same lock at the same time, or that the lock experiences <em>contention</em>. A major challenge in kernel design is to avoid lock contention. Xv6 does little of that, but sophisticated kernels organize data structures and algorithms specifically to avoid lock contention. In the list example, a kernel may maintain a free list per CPU and only touch another CPU’s free list if the CPU’s list is empty and it must steal memory from another CPU. Other use cases may require more complicated designs.</p>
<p>The placement of locks is also important for performance. For example, it would be correct to move acquire earlier in push: it is fine to move the call to acquire up to before line 13. This may reduce performance because then the calls to malloc are also serialized. The section “Using locks” below provides some guidelines for where to insert acquire and release invocations.</p>
<h1 id="6-2-Code-Locks"><a href="#6-2-Code-Locks" class="headerlink" title="6.2     Code: Locks"></a>6.2     Code: Locks</h1><p>Xv6 has two types of locks: spinlocks and sleep-locks. We’ll start with spinlocks. Xv6 represents a spinlock as a struct spinlock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.h#L2">(kernel/spinlock.h:2)</a>. The important field in the structure is</p>
<p>locked, a word that is zero when the lock is available and non-zero when it is held. Logically, xv6 should acquire a lock by executing code like</p>
<p>21             void</p>
<p>22             acquire(struct spinlock *lk) // does not work!</p>
<p>23     {</p>
<p>24       for(;;) {</p>
<p>25                        if(lk-&gt;locked == 0) {</p>
<p>26                             lk-&gt;locked = 1;</p>
<p>27                             break;</p>
<p>28          }</p>
<p>29       }</p>
<p>30     }</p>
<p>Unfortunately, this implementation does not guarantee mutual exclusion on a multiprocessor. It could happen that two CPUs simultaneously reach line 25, see that lk-&gt;locked is zero, and then both grab the lock by executing line 26. At this point, two different CPUs hold the lock, which violates the mutual exclusion property. What we need is a way to make lines 25 and 26 execute as an <em>atomic</em> (i.e., indivisible) step.</p>
<p>Because locks are widely used, multi-core processors usually provide instructions that imple- ment an atomic version of lines 25 and 26. On the RISC-V this instruction is amoswap r, a. amoswap reads the value at the memory address a, writes the contents of register r to that address, and puts the value it read into r. That is, it swaps the contents of the register and the memory address. It performs this sequence atomically, using special hardware to prevent any other CPU from using the memory address between the read and the write.</p>
<p>Xv6’s acquire <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L22">(kernel/spinlock.c:22) </a>uses the portable C library call sync_lock_test_and_set, which boils down to the amoswap instruction; the return value is the old (swapped) contents of</p>
<p>lk-&gt;locked. The acquire function wraps the swap in a loop, retrying (spinning) until it has acquired the lock. Each iteration swaps one into lk-&gt;locked and checks the previous value; if the previous value is zero, then we’ve acquired the lock, and the swap will have set lk-&gt;locked to one. If the previous value is one, then some other CPU holds the lock, and the fact that we atomically swapped one into lk-&gt;locked didn’t change its value.</p>
<p>Once the lock is acquired, acquire records, for debugging, the CPU that acquired the lock.</p>
<p>The lk-&gt;cpu field is protected by the lock and must only be changed while holding the lock.</p>
<p>The function release <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L47">(kernel/spinlock.c:47) </a>is the opposite of acquire: it clears the lk-&gt;cpu field and then releases the lock. Conceptually, the release just requires assigning zero to lk-&gt;locked. The C standard allows compilers to implement an assignment with multiple store instructions, so a</p>
<p>C assignment might be non-atomic with respect to concurrent code. Instead, release uses the C library function sync_lock_release that performs an atomic assignment. This function also boils down to a RISC-V amoswap instruction.</p>
<h1 id="6-3-Code-Using-locks"><a href="#6-3-Code-Using-locks" class="headerlink" title="6.3     Code: Using locks"></a>6.3     Code: Using locks</h1><p>Xv6 uses locks in many places to avoid race conditions. As described above, kalloc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L69">(kernel/kalloc.c:69)</a></p>
<p>and kfree <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L47">(kernel/kalloc.c:47) </a>form a good example. Try Exercises 1 and 2 to see what happens if those functions omit the locks. You’ll likely find that it’s difficult to trigger incorrect behavior, suggesting that it’s hard to reliably test whether code is free from locking errors and races. It is not unlikely that xv6 has some races.</p>
<p>A hard part about using locks is deciding how many locks to use and which data and invariants each lock should protect. There are a few basic principles. First, any time a variable can be written by one CPU at the same time that another CPU can read or write it, a lock should be used to keep the two operations from overlapping. Second, remember that locks protect invariants: if an invariant involves multiple memory locations, typically all of them need to be protected by a single lock to ensure the invariant is maintained.</p>
<p>The rules above say when locks are necessary but say nothing about when locks are unnec- essary, and it is important for efficiency not to lock too much, because locks reduce parallelism. If parallelism isn’t important, then one could arrange to have only a single thread and not worry about locks. A simple kernel can do this on a multiprocessor by having a single lock that must  be acquired on entering the kernel and released on exiting the kernel (though system calls such as pipe reads or wait would pose a problem). Many uniprocessor operating systems have been converted to run on multiprocessors using this approach, sometimes called a “big kernel lock,” but the approach sacrifices parallelism: only one CPU can execute in the kernel at a time. If the kernel does any heavy computation, it would be more efficient to use a larger set of more fine-grained locks, so that the kernel could execute on multiple CPUs simultaneously.</p>
<p>As an example of coarse-grained locking, xv6’s kalloc.c allocator has a single free list pro- tected by a single lock. If multiple processes on different CPUs try to allocate pages at the same time, each will have to wait for its turn by spinning in acquire. Spinning reduces performance, since it’s not useful work. If contention for the lock wasted a significant fraction of CPU time, perhaps performance could be improved by changing the allocator design to have multiple free lists, each with its own lock, to allow truly parallel allocation.</p>
<p>As an example of fine-grained locking, xv6 has a separate lock for each file, so that processes that manipulate different files can often proceed without waiting for each other’s locks. The file locking scheme could be made even more fine-grained if one wanted to allow processes to simul- taneously write different areas of the same file. Ultimately lock granularity decisions need to be driven by performance measurements as well as complexity considerations.</p>
<p>As subsequent chapters explain each part of xv6, they will mention examples of xv6’s use of locks to deal with concurrency. As a preview, Figure 6.3 lists all of the locks in xv6.</p>
<h1 id="6-4-Deadlock-and-lock-ordering"><a href="#6-4-Deadlock-and-lock-ordering" class="headerlink" title="6.4     Deadlock and lock ordering"></a>6.4     Deadlock and lock ordering</h1><p>If a code path through the kernel must hold several locks at the same time, it is important that all code paths acquire those locks in the same order. If they don’t, there is a risk of <em>deadlock</em>. Let’s say two code paths in xv6 need locks A and B, but code path 1 acquires locks in the order A then</p>
<h4 id="Lock-Description"><a href="#Lock-Description" class="headerlink" title="      Lock           Description"></a><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image045.gif" alt="img">      Lock           Description</h4><p>bcache.lock      Protects allocation of block buffer cache entries</p>
<p>cons.lock        Serializes access to console hardware, avoids intermixed output ftable.lock               Serializes allocation of a struct file in file table</p>
<p>icache.lock      Protects allocation of inode cache entries</p>
<p>vdisk_lock      Serializes access to disk hardware and queue of DMA descriptors kmem.lock Serializes allocation of memory</p>
<p>log.lock         Serializes operations on the transaction log pipe’s pi-&gt;lock   Serializes operations on each pipe pid_lock               Serializes increments of next_pid</p>
<p>proc’s p-&gt;lock    Serializes changes to process’s state tickslock        Serializes operations on the ticks counter</p>
<p>inode’s ip-&gt;lock  Serializes operations on each inode and its content buf’s b-&gt;lock               Serializes operations on each block buffer</p>
<p>Figure 6.3: Locks in xv6</p>
<p>B, and the other path acquires them in the order B then A. Suppose thread T1 executes code path 1 and acquires lock A, and thread T2 executes code path 2 and acquires lock B. Next T1 will try to acquire lock B, and T2 will try to acquire lock A. Both acquires will block indefinitely, because in both cases the other thread holds the needed lock, and won’t release it until its acquire returns. To avoid such deadlocks, all code paths must acquire locks in the same order. The need for a global lock acquisition order means that locks are effectively part of each function’s specification: callers must invoke functions in a way that causes locks to be acquired in the agreed-on order.</p>
<p>Xv6 has many lock-order chains of length two involving per-process locks (the lock in each struct proc) due to the way that sleep works (see Chapter 7). For example, consoleintr <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/console.c#L138">(kernel/console.c:138) </a>is the interrupt routine which handles typed characters. When a newline ar- rives, any process that is waiting for console input should be woken up. To do this, consoleintr holds cons.lock while calling wakeup, which acquires the waiting process’s lock in order to wake it up. In consequence, the global deadlock-avoiding lock order includes the rule that cons.lock must be acquired before any process lock. The file-system code contains xv6’s longest lock chains.</p>
<p>For example, creating a file requires simultaneously holding a lock on the directory, a lock on the new file’s inode, a lock on a disk block buffer, the disk driver’s vdisk_lock, and the calling pro- cess’s p-&gt;lock. To avoid deadlock, file-system code always acquires locks in the order mentioned in the previous sentence.</p>
<p>Honoring a global deadlock-avoiding order can be surprisingly difficult. Sometimes the lock order conflicts with logical program structure, e.g., perhaps code module M1 calls module M2, but the lock order requires that a lock in M2 be acquired before a lock in M1. Sometimes the identities of locks aren’t known in advance, perhaps because one lock must be held in order to discover the identity of the lock to be acquired next. This kind of situation arises in the file system as it looks up successive components in a path name, and in the code for wait and exit as they search the table of processes looking for child processes. Finally, the danger of deadlock is often a constraint on</p>
<p>how fine-grained one can make a locking scheme, since more locks often means more opportunity for deadlock. The need to avoid deadlock is often a major factor in kernel implementation.</p>
<h1 id="6-5-Locks-and-interrupt-handlers"><a href="#6-5-Locks-and-interrupt-handlers" class="headerlink" title="6.5     Locks and interrupt handlers"></a>6.5     Locks and interrupt handlers</h1><p>Some xv6 spinlocks protect data that is used by both threads and interrupt handlers. For example, the clockintr timer interrupt handler might increment ticks <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L163">(kernel/trap.c:163) </a>at about the same time that a kernel thread reads ticks in sys_sleep <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysproc.c#L64">(kernel/sysproc.c:64)</a>. The lock tickslock serializes the two accesses.</p>
<p>The interaction of spinlocks and interrupts raises a potential danger. Suppose sys_sleep holds tickslock, and its CPU is interrupted by a timer interrupt. clockintr would try to acquire tickslock, see it was held, and wait for it to be released. In this situation, tickslock will never be released: only sys_sleep can release it, but sys_sleep will not continue running until clockintr returns. So the CPU will deadlock, and any code that needs either lock will also freeze. To avoid this situation, if a spinlock is used by an interrupt handler, a CPU must never hold  that lock with interrupts enabled. Xv6 is more conservative: when a CPU acquires any lock, xv6 always disables interrupts on that CPU. Interrupts may still occur on other CPUs, so an interrupt’s</p>
<p>acquire can wait for a thread to release a spinlock; just not on the same CPU.</p>
<p>xv6 re-enables interrupts when a CPU holds no spinlocks; it must do a little book-keeping to cope with nested critical sections. acquire calls push_off <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L89">(kernel/spinlock.c:89) </a>and release calls pop_off <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L100">(kernel/spinlock.c:100) </a>to track the nesting level of locks on the current CPU. When that count reaches zero, pop_off restores the interrupt enable state that existed at the start of the outermost critical section. The intr_off and intr_on functions execute RISC-V instructions to disable and enable interrupts, respectively.</p>
<p>It is important that acquire call push_off strictly before setting lk-&gt;locked <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L28">(kernel/spin-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L28">lock.c:28)</a>. If the two were reversed, there would be a brief window when the lock was held with interrupts enabled, and an unfortunately timed interrupt would deadlock the system. Similarly, it is important that release call pop_off only after releasing the lock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L66">(kernel/spinlock.c:66)</a>.</p>
<h1 id="6-6-Instruction-and-memory-ordering"><a href="#6-6-Instruction-and-memory-ordering" class="headerlink" title="6.6     Instruction and memory ordering"></a>6.6     Instruction and memory ordering</h1><p>It is natural to think of programs executing in the order in which source code statements appear. Many compilers and CPUs, however, execute code out of order to achieve higher performance. If an instruction takes many cycles to complete, a CPU may issue the instruction early so that it can overlap with other instructions and avoid CPU stalls. For example, a CPU may notice that in a serial sequence of instructions A and B are not dependent on each other. The CPU may start instruction B first, either because its inputs are ready before A’s inputs, or in order to overlap execution of A and B. A compiler may perform a similar re-ordering by emitting instructions for one statement before the instructions for a statement that precedes it in the source.</p>
<p>Compilers and CPUs follow rules when they re-order to ensure that they don’t change the results of correctly-written serial code. However, the rules do allow re-ordering that changes the</p>
<p>results of concurrent code, and can easily lead to incorrect behavior on multiprocessors [2, 3]. The CPU’s ordering rules are called the <em>memory model</em>.</p>
<p>For example, in this code for push, it would be a disaster if the compiler or CPU moved the store corresponding to line 4 to a point after the release on line 6:</p>
<p>1                     l = malloc(sizeof *l);</p>
<p>2                     l-&gt;data = data;</p>
<p>3                     acquire(&amp;listlock);</p>
<p>4                     l-&gt;next = list;</p>
<p>5                     list = l;</p>
<p>6                     release(&amp;listlock);</p>
<p>If such a re-ordering occurred, there would be a window during which another CPU could acquire the lock and observe the updated list, but see an uninitialized list-&gt;next.</p>
<p>To tell the hardware and compiler not to perform such re-orderings, xv6 uses sync_synchronize()</p>
<p>in both acquire <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L22">(kernel/spinlock.c:22) </a>and release <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L47">(kernel/spinlock.c:47)</a>. sync_synchronize()</p>
<p>is a <em>memory barrier</em>: it tells the compiler and CPU to not reorder loads or stores across the barrier. The barriers in xv6’s acquire and release force order in almost all cases where it matters, since xv6 uses locks around accesses to shared data. Chapter 9 discusses a few exceptions.</p>
<h1 id="6-7-Sleep-locks"><a href="#6-7-Sleep-locks" class="headerlink" title="6.7     Sleep locks"></a>6.7     Sleep locks</h1><p>Sometimes xv6 needs to hold a lock for a long time. For example, the file system (Chapter 8) keeps a file locked while reading and writing its content on the disk, and these disk operations can take tens of milliseconds. Holding a spinlock that long would lead to waste if another process wanted to acquire it, since the acquiring process would waste CPU for a long time while spinning. Another drawback of spinlocks is that a process cannot yield the CPU while retaining a spinlock; we’d like to do this so that other processes can use the CPU while the process with the lock waits for the disk. Yielding while holding a spinlock is illegal because it might lead to deadlock if a second thread then tried to acquire the spinlock; since acquire doesn’t yield the CPU, the second thread’s spinning might prevent the first thread from running and releasing the lock. Yielding while holding a lock would also violate the requirement that interrupts must be off while a spinlock is held. Thus we’d like a type of lock that yields the CPU while waiting to acquire, and allows yields (and interrupts) while the lock is held.</p>
<p>Xv6 provides such locks in the form of <em>sleep-locks</em>. acquiresleep <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sleeplock.c#L22">(kernel/sleeplock.c:22)</a> yields the CPU while waiting, using techniques that will be explained in Chapter 7. At a high level, a sleep-lock has a locked field that is protected by a spinlock, and acquiresleep ’s call to sleep atomically yields the CPU and releases the spinlock. The result is that other threads can execute while acquiresleep waits.</p>
<p>Because sleep-locks leave interrupts enabled, they cannot be used in interrupt handlers. Be- cause acquiresleep may yield the CPU, sleep-locks cannot be used inside spinlock critical sections (though spinlocks can be used inside sleep-lock critical sections).</p>
<p>Spin-locks are best suited to short critical sections, since waiting for them wastes CPU time; sleep-locks work well for lengthy operations.</p>
<h1 id="6-8-Real-world"><a href="#6-8-Real-world" class="headerlink" title="6.8     Real world"></a>6.8     Real world</h1><p>Programming with locks remains challenging despite years of research into concurrency primitives and parallelism. It is often best to conceal locks within higher-level constructs like synchronized queues, although xv6 does not do this. If you program with locks, it is wise to use a tool that attempts to identify race conditions, because it is easy to miss an invariant that requires a lock.</p>
<p>Most operating systems support POSIX threads (Pthreads), which allow a user process to have several threads running concurrently on different CPUs. Pthreads has support for user-level locks, barriers, etc. Supporting Pthreads requires support from the operating system. For example, it should be the case that if one pthread blocks in a system call, another pthread of the same process should be able to run on that CPU. As another example, if a pthread changes its process’s address space (e.g., maps or unmaps memory), the kernel must arrange that other CPUs that run threads of the same process update their hardware page tables to reflect the change in the address space.</p>
<p>It is possible to implement locks without atomic instructions [8], but it is expensive, and most operating systems use atomic instructions.</p>
<p>Locks can be expensive if many CPUs try to acquire the same lock at the same time. If one CPU has a lock cached in its local cache, and another CPU must acquire the lock, then the atomic instruction to update the cache line that holds the lock must move the line from the one CPU’s cache to the other CPU’s cache, and perhaps invalidate any other copies of the cache line. Fetching a cache line from another CPU’s cache can be orders of magnitude more expensive than fetching a line from a local cache.</p>
<p>To avoid the expenses associated with locks, many operating systems use lock-free data struc- tures and algorithms [5, 10]. For example, it is possible to implement a linked list like the one in the beginning of the chapter that requires no locks during list searches, and one atomic instruction to insert an item in a list. Lock-free programming is more complicated, however, than programming locks; for example, one must worry about instruction and memory reordering. Programming with locks is already hard, so xv6 avoids the additional complexity of lock-free programming.</p>
<h1 id="6-9-Exercises"><a href="#6-9-Exercises" class="headerlink" title="6.9     Exercises"></a>6.9     Exercises</h1><p>\1.   Comment out the calls to acquire and release in kalloc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L69">(kernel/kalloc.c:69)</a>. This seems like it should cause problems for kernel code that calls kalloc; what symptoms do you expect to see? When you run xv6, do you see these symptoms? How about when running usertests? If you don’t see a problem, why not? See if you can provoke a problem by inserting dummy loops into the critical section of kalloc.</p>
<p>\2.   Suppose that you instead commented out the locking in kfree (after restoring locking  in kalloc). What might now go wrong? Is lack of locks in kfree less harmful than in kalloc?</p>
<p>\3.   If two CPUs call kalloc at the same time, one will have to wait for the other, which is bad for performance. Modify kalloc.c to have more parallelism, so that simultaneous calls to kalloc from different CPUs can proceed without waiting for each other.</p>
<p>\4.   Write a parallel program using POSIX threads, which is supported on most operating sys- tems. For example, implement a parallel hash table and measure if the number of puts/gets scales with increasing number of cores.</p>
<p>\5.   Implement a subset of Pthreads in xv6. That is, implement a user-level thread library so that a user process can have more than 1 thread and arrange that these threads can run in parallel on different CPUs. Come up with a design that correctly handles a thread making a blocking system call and changing its shared address space.</p>
<p><strong>Chapter 7 Scheduling</strong></p>
<p>Any operating system is likely to run with more processes than the computer has CPUs, so a plan is needed to time-share the CPUs among the processes. Ideally the sharing would be transparent to user processes. A common approach is to provide each process with the illusion that it has its own virtual CPU by <em>multiplexing</em> the processes onto the hardware CPUs. This chapter explains how xv6 achieves this multiplexing.</p>
<h1 id="7-1-Multiplexing"><a href="#7-1-Multiplexing" class="headerlink" title="7.1     Multiplexing"></a>7.1     Multiplexing</h1><p>Xv6 multiplexes by switching each CPU from one process to another in two situations. First, xv6’s sleep and wakeup mechanism switches when a process waits for device or pipe I/O to complete, or waits for a child to exit, or waits in the sleep system call. Second, xv6 periodically forces a switch to cope with processes that compute for long periods without sleeping. This multiplexing creates the illusion that each process has its own CPU, just as xv6 uses the memory allocator and hardware page tables to create the illusion that each process has its own memory.</p>
<p>Implementing multiplexing poses a few challenges. First, how to switch from one process to another? Although the idea of context switching is simple, the implementation is some of the most opaque code in xv6. Second, how to force switches in a way that is transparent to user processes? Xv6 uses the standard technique of driving context switches with timer interrupts. Third, many CPUs may be switching among processes concurrently, and a locking plan is necessary to avoid races. Fourth, a process’s memory and other resources must be freed when the process exits, but it cannot do all of this itself because (for example) it can’t free its own kernel stack while still using it. Fifth, each core of a multi-core machine must remember which process it is executing so that system calls affect the correct process’s kernel state. Finally, sleep and wakeup allow a process to give up the CPU and sleep waiting for an event, and allows another process to wake the first process up. Care is needed to avoid races that result in the loss of wakeup notifications. Xv6 tries to solve these problems as simply as possible, but nevertheless the resulting code is tricky.</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image049.gif" alt="img"></p>
<p>Kernel</p>
<p>Figure 7.1: Switching from one user process to another. In this example, xv6 runs with one CPU (and thus one scheduler thread).</p>
<h1 id="7-2-Code-Context-switching"><a href="#7-2-Code-Context-switching" class="headerlink" title="7.2     Code: Context switching"></a>7.2     Code: Context switching</h1><p>Figure 7.1 outlines the steps involved in switching from one user process to another: a user-kernel transition (system call or interrupt) to the old process’s kernel thread, a context switch to the current CPU’s scheduler thread, a context switch to a new process’s kernel thread, and a trap return to the user-level process. The xv6 scheduler has a dedicated thread (saved registers and stack) per CPU because it is not safe for the scheduler execute on the old process’s kernel stack: some other core might wake the process up and run it, and it would be a disaster to use the same stack on two different cores. In this section we’ll examine the mechanics of switching between a kernel thread and a scheduler thread.</p>
<p>Switching from one thread to another involves saving the old thread’s CPU registers, and restor- ing the previously-saved registers of the new thread; the fact that the stack pointer and program counter are saved and restored means that the CPU will switch stacks and switch what code it is executing.</p>
<p>The function swtch performs the saves and restores for a kernel thread switch. swtch doesn’t directly know about threads; it just saves and restores register sets, called <em>contexts</em>. When it is time for a process to give up the CPU, the process’s kernel thread calls swtch to save its own context and return to the scheduler context. Each context is contained in a struct context <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.h#L2">(kernel/proc.h:2)</a>, itself contained in a process’s struct proc or a CPU’s struct cpu. Swtch takes two arguments: struct context *old and struct context *new. It saves the current registers in old, loads registers from new, and returns.</p>
<p>Let’s follow a process through swtch into the scheduler. We saw in Chapter 4 that one possibil- ity at the end of an interrupt is that usertrap calls yield. Yield in turn calls sched, which calls swtch to save the current context in p-&gt;context and switch to the scheduler context previously saved in cpu-&gt;scheduler <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L509">(kernel/proc.c:509)</a>.</p>
<p>Swtch <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/swtch.S#L3">(kernel/swtch.S:3) </a>saves only callee-saved registers; caller-saved registers are saved on the stack (if needed) by the calling C code. Swtch knows the offset of each register’s field in struct context. It does not save the program counter. Instead, swtch saves the ra register, which holds the return address from which swtch was called. Now swtch restores registers from</p>
<p>the new context, which holds register values saved by a previous swtch. When swtch returns, it returns to the instructions pointed to by the restored ra register, that is, the instruction from which the new thread previously called swtch. In addition, it returns on the new thread’s stack.</p>
<p>In our example, sched called swtch to switch to cpu-&gt;scheduler, the per-CPU scheduler context. That context had been saved by scheduler’s call to swtch <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L475">(kernel/proc.c:475)</a>. When the swtch we have been tracing returns, it returns not to sched but to scheduler, and its stack pointer points at the current CPU’s scheduler stack.</p>
<h1 id="7-3-Code-Scheduling"><a href="#7-3-Code-Scheduling" class="headerlink" title="7.3     Code: Scheduling"></a>7.3     Code: Scheduling</h1><p>The last section looked at the low-level details of swtch; now let’s take swtch as a given and examine switching from one process’s kernel thread through the scheduler to another process. The scheduler exists in the form of a special thread per CPU, each running the scheduler function. This function is in charge of choosing which process to run next. A process that wants to give up the CPU must acquire its own process lock p-&gt;lock, release any other locks it is holding, update its own state (p-&gt;state), and then call sched. Yield <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L515">(kernel/proc.c:515) </a>follows this convention, as do sleep and exit, which we will examine later. Sched double-checks those conditions <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L499-L504">(kernel/proc.c:499-504) </a>and then an implication of those conditions: since a lock is held, interrupts should be disabled. Finally, sched calls swtch to save the current context in p-&gt;context and switch to the scheduler context in cpu-&gt;scheduler. Swtch returns on the scheduler’s stack as though scheduler’s swtch had returned The scheduler continues the for loop, finds a process to run, switches to it, and the cycle repeats.</p>
<p>We just saw that xv6 holds p-&gt;lock across calls to swtch: the caller of swtch must already hold the lock, and control of the lock passes to the switched-to code. This convention is unusual with locks; usually the thread that acquires a lock is also responsible for releasing the lock, which makes it easier to reason about correctness. For context switching it is necessary to break this convention because p-&gt;lock protects invariants on the process’s state and context fields that are not true while executing in swtch. One example of a problem that could arise if p-&gt;lock were not held during swtch: a different CPU might decide to run the process after yield had set its state to RUNNABLE, but before swtch caused it to stop using its own kernel stack. The result would be two CPUs running on the same stack, which cannot be right.</p>
<p>A kernel thread always gives up its CPU in sched and always switches to the same loca- tion in the scheduler, which (almost) always switches to some kernel thread that previously called sched. Thus, if one were to print out the line numbers where xv6 switches threads, one would ob- serve the following simple pattern: <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L475">(kernel/proc.c:475)</a>, <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L509">(kernel/proc.c:509)</a>, <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L475">(kernel/proc.c:475)</a>, <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L509">(ker-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L509">nel/proc.c:509)</a>, and so on. The procedures in which this stylized switching between two threads happens are sometimes referred to as <em>coroutines</em>; in this example, sched and scheduler are co-routines of each other.</p>
<p>There is one case when the scheduler’s call to swtch does not end up in sched. When a new process is first scheduled, it begins at forkret <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L527">(kernel/proc.c:527)</a>. Forkret exists to release the p-&gt;lock; otherwise, the new process could start at usertrapret.</p>
<p>Scheduler <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L457">(kernel/proc.c:457) </a>runs a simple loop: find a process to run, run it until it yields,</p>
<p>repeat. The scheduler loops over the process table looking for a runnable process, one that has p-&gt;state == RUNNABLE. Once it finds a process, it sets the per-CPU current process variable c-&gt;proc, marks the process as RUNNING, and then calls swtch to start running it <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L470-L475">(kernel/proc.c:470-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L470-L475">475)</a>.</p>
<p>One way to think about the structure of the scheduling code is that it enforces a set of invariants about each process, and holds p-&gt;lock whenever those invariants are not true. One invariant is that if a process is RUNNING, a timer interrupt’s yield must be able to safely switch away from the process; this means that the CPU registers must hold the process’s register values (i.e. swtch hasn’t moved them to a context), and c-&gt;proc must refer to the process. Another invariant is that if a process is RUNNABLE, it must be safe for an idle CPU’s scheduler to run it; this means that p-&gt;context must hold the process’s registers (i.e., they are not actually in the real registers), that no CPU is executing on the process’s kernel stack, and that no CPU’s c-&gt;proc refers to the process. Observe that these properties are often not true while p-&gt;lock is held.</p>
<p>Maintaining the above invariants is the reason why xv6 often acquires p-&gt;lock in one thread and releases it in other, for example acquiring in yield and releasing in scheduler. Once yield has started to modify a running process’s state to make it RUNNABLE, the lock must remain held until the invariants are restored: the earliest correct release point is after scheduler (running on its own stack) clears c-&gt;proc. Similarly, once scheduler starts to convert a RUNNABLE process to RUNNING, the lock cannot be released until the kernel thread is completely running (after the swtch, for example in yield).</p>
<p>p-&gt;lock protects other things as well: the interplay between exit and wait, the machinery to avoid lost wakeups (see Section 7.5), and avoidance of races between a process exiting and other processes reading or writing its state (e.g., the exit system call looking at p-&gt;pid and setting p-&gt;killed <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L611">(kernel/proc.c:611)</a>). It might be worth thinking about whether the different functions of p-&gt;lock could be split up, for clarity and perhaps for performance.</p>
<h1 id="7-4-Code-mycpu-and-myproc"><a href="#7-4-Code-mycpu-and-myproc" class="headerlink" title="7.4     Code: mycpu and myproc"></a>7.4     Code: mycpu and myproc</h1><p>Xv6 often needs a pointer to the current process’s proc structure. On a uniprocessor one could have a global variable pointing to the current proc. This doesn’t work on a multi-core machine, since each core executes a different process. The way to solve this problem is to exploit the fact that each core has its own set of registers; we can use one of those registers to help find per-core information.</p>
<p>Xv6 maintains a struct cpu for each CPU <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.h#L22">(kernel/proc.h:22)</a>, which records the process cur- rently running on that CPU (if any), saved registers for the CPU’s scheduler thread, and the count of nested spinlocks needed to manage interrupt disabling. The function mycpu <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L60">(kernel/proc.c:60)</a> returns a pointer to the current CPU’s struct cpu. RISC-V numbers its CPUs, giving each a <em>hartid</em>. Xv6 ensures that each CPU’s hartid is stored in that CPU’s tp register while in the kernel. This allows mycpu to use tp to index an array of cpu structures to find the right one.</p>
<p>Ensuring that a CPU’s tp always holds the CPU’s hartid is a little involved. mstart sets the tp register early in the CPU’s boot sequence, while still in machine mode <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/start.c#L46">(kernel/start.c:46)</a>. usertrapret saves tp in the trampoline page, because the user process might modify tp. Finally,</p>
<p>uservec restores that saved tp when entering the kernel from user space <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S#L70">(kernel/trampoline.S:70)</a>. The compiler guarantees never to use the tp register. It would be more convenient if RISC-V allowed xv6 to read the current hartid directly, but that is allowed only in machine mode, not in supervisor mode.</p>
<p>The return values of cpuid and mycpu are fragile: if the timer were to interrupt and cause the thread to yield and then move to a different CPU, a previously returned value would no longer be correct. To avoid this problem, xv6 requires that callers disable interrupts, and only enable them after they finish using the returned struct cpu.</p>
<p>The function myproc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L68">(kernel/proc.c:68) </a>returns the struct proc pointer for the process that is running on the current CPU. myproc disables interrupts, invokes mycpu, fetches the current process pointer (c-&gt;proc) out of the struct cpu, and then enables interrupts. The return value of myproc is safe to use even if interrupts are enabled: if a timer interrupt moves the calling process to a different CPU, its struct proc pointer will stay the same.</p>
<h1 id="7-5-Sleep-and-wakeup"><a href="#7-5-Sleep-and-wakeup" class="headerlink" title="7.5     Sleep and wakeup"></a>7.5     Sleep and wakeup</h1><p>Scheduling and locks help conceal the existence of one process from another, but so far we have no abstractions that help processes intentionally interact. Many mechanisms have been invented to solve this problem. Xv6 uses one called sleep and wakeup, which allow one process to sleep waiting for an event and another process to wake it up once the event has happened. Sleep and wakeup are often called <em>sequence coordination</em> or <em>conditional synchronization</em> mechanisms.</p>
<p>To illustrate, let’s consider a synchronization mechanism called a <em>semaphore</em> [4] that coordi- nates producers and consumers. A semaphore maintains a count and provides two operations. The “V” operation (for the producer) increments the count. The “P” operation (for the consumer) waits until the count is non-zero, and then decrements it and returns. If there were only one producer thread and one consumer thread, and they executed on different CPUs, and the compiler didn’t optimize too aggressively, this implementation would be correct:</p>
<p>100          struct semaphore {</p>
<p>101                struct spinlock lock;</p>
<p>102                int count;</p>
<p>103    };</p>
<p>104</p>
<p>105          void</p>
<p>106          V(struct semaphore *s)</p>
<p>107    {</p>
<p>108                  acquire(&amp;s-&gt;lock);</p>
<p>109                  s-&gt;count += 1;</p>
<p>110                  release(&amp;s-&gt;lock);</p>
<p>111    }</p>
<p>112</p>
<p>113          void</p>
<p>114          P(struct semaphore *s)</p>
<p>115    {</p>
<p>116       while(s-&gt;count == 0)</p>
<p>117          ;</p>
<p>118                  acquire(&amp;s-&gt;lock);</p>
<p>119                  s-&gt;count -= 1;</p>
<p>120                  release(&amp;s-&gt;lock);</p>
<p>121 }</p>
<p>The implementation above is expensive. If the producer acts rarely, the consumer will spend most of its time spinning in the while loop hoping for a non-zero count. The consumer’s CPU could find more productive work than with <em>busy waiting</em> by repeatedly <em>polling</em> s-&gt;count. Avoid- ing busy waiting requires a way for the consumer to yield the CPU and resume only after V incre- ments the count.</p>
<p>Here’s a step in that direction, though as we will see it is not enough. Let’s imagine a pair  of calls, sleep and wakeup, that work as follows. Sleep(chan) sleeps on the arbitrary value chan, called the <em>wait channel</em>. Sleep puts the calling process to sleep, releasing the CPU for other work. Wakeup(chan) wakes all processes sleeping on chan (if any), causing their sleep calls to return. If no processes are waiting on chan, wakeup does nothing. We can change the semaphore implementation to use sleep and wakeup (changes highlighted in yellow):</p>
<p>200          void</p>
<p>201          V(struct semaphore *s)</p>
<p>202 {</p>
<p>203                  acquire(&amp;s-&gt;lock);</p>
<p>204                  s-&gt;count += 1;</p>
<p>205                  wakeup(s);</p>
<p>206                  release(&amp;s-&gt;lock);</p>
<p>207    }</p>
<p>208</p>
<p>209          void</p>
<p>210          P(struct semaphore *s)</p>
<p>211    {</p>
<p>212                while(s-&gt;count == 0)</p>
<p>213                     sleep(s);</p>
<p>214                acquire(&amp;s-&gt;lock);</p>
<p>215                s-&gt;count -= 1;</p>
<p>216                release(&amp;s-&gt;lock);</p>
<p>217 }</p>
<p>P now gives up the CPU instead of spinning, which is nice. However, it turns out not to be straightforward to design sleep and wakeup with this interface without suffering from what is known as the <em>lost wake-up</em> problem. Suppose that P finds that s-&gt;count == 0 on line 212. While P is between lines 212 and 213, V runs on another CPU: it changes s-&gt;count to be nonzero and calls wakeup, which finds no processes sleeping and thus does nothing. Now P continues executing at line 213: it calls sleep and goes to sleep. This causes a problem: P is asleep waiting for a V call that has already happened. Unless we get lucky and the producer calls V again, the consumer will wait forever even though the count is non-zero.</p>
<p>The root of this problem is that the invariant that P only sleeps when s-&gt;count == 0 is violated by V running at just the wrong moment. An incorrect way to protect the invariant would be to move the lock acquisition (highlighted in yellow below) in P so that its check of the count and its call to sleep are atomic:</p>
<p>300          void</p>
<p>301          V(struct semaphore *s)</p>
<p>302    {</p>
<p>303                acquire(&amp;s-&gt;lock);</p>
<p>304                s-&gt;count += 1;</p>
<p>305                wakeup(s);</p>
<p>306                release(&amp;s-&gt;lock);</p>
<p>307    }</p>
<p>308</p>
<p>309          void</p>
<p>310          P(struct semaphore *s)</p>
<p>311    {</p>
<p>312                acquire(&amp;s-&gt;lock);</p>
<p>313                while(s-&gt;count == 0)</p>
<p>314                     sleep(s);</p>
<p>315                s-&gt;count -= 1;</p>
<p>316                release(&amp;s-&gt;lock);</p>
<p>317 }</p>
<p>One might hope that this version of P would avoid the lost wakeup because the lock prevents V from executing between lines 313 and 314. It does that, but it also deadlocks: P holds the lock while it sleeps, so V will block forever waiting for the lock.</p>
<p>We’ll fix the preceding scheme by changing sleep’s interface: the caller must pass the <em>con- dition lock</em> to sleep so it can release the lock after the calling process is marked as asleep and waiting on the sleep channel. The lock will force a concurrent V to wait until P has finished putting itself to sleep, so that the wakeup will find the sleeping consumer and wake it up. Once the con- sumer is awake again sleep reacquires the lock before returning. Our new correct sleep/wakeup scheme is usable as follows (change highlighted in yellow):</p>
<p>400          void</p>
<p>401          V(struct semaphore *s)</p>
<p>402 {</p>
<p>403      acquire(&amp;s-&gt;lock);</p>
<p>404      s-&gt;count += 1;</p>
<p>405      wakeup(s);</p>
<p>406      release(&amp;s-&gt;lock);</p>
<p>407    }</p>
<p>408</p>
<p>409    void</p>
<p>410    P(struct semaphore *s)</p>
<p>411 {</p>
<p>412      acquire(&amp;s-&gt;lock);</p>
<table>
<thead>
<tr>
<th>413</th>
<th></th>
<th>while(s-&gt;count  == 0)</th>
</tr>
</thead>
<tbody><tr>
<td>414</td>
<td></td>
<td>sleep(s, &amp;s-&gt;lock);</td>
</tr>
<tr>
<td>415</td>
<td></td>
<td>s-&gt;count -= 1;</td>
</tr>
<tr>
<td>416</td>
<td></td>
<td>release(&amp;s-&gt;lock);</td>
</tr>
<tr>
<td>417</td>
<td>}</td>
<td></td>
</tr>
</tbody></table>
<p>The fact that P holds s-&gt;lock prevents V from trying to wake it up between P’s check of c-&gt;count and its call to sleep. Note, however, that we need sleep to atomically release s-&gt;lock and put the consuming process to sleep.</p>
<h1 id="7-6-Code-Sleep-and-wakeup"><a href="#7-6-Code-Sleep-and-wakeup" class="headerlink" title="7.6     Code: Sleep and wakeup"></a>7.6     Code: Sleep and wakeup</h1><p>Let’s look at the implementation of sleep <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L548">(kernel/proc.c:548) </a>and wakeup <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L582">(kernel/proc.c:582)</a>. The basic idea is to have sleep mark the current process as SLEEPING and then call sched to re- lease the CPU; wakeup looks for a process sleeping on the given wait channel and marks it as RUNNABLE. Callers of sleep and wakeup can use any mutually convenient number as the chan- nel. Xv6 often uses the address of a kernel data structure involved in the waiting.</p>
<p>Sleep acquires p-&gt;lock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L559">(kernel/proc.c:559)</a>. Now the process going to sleep holds both p-&gt;lock and lk. Holding lk was necessary in the caller (in the example, P): it ensured that no other pro- cess (in the example, one running V) could start a call to wakeup(chan). Now that sleep holds p-&gt;lock, it is safe to release lk: some other process may start a call to wakeup(chan), but wakeup will wait to acquire p-&gt;lock, and thus will wait until sleep has finished putting the process to sleep, keeping the wakeup from missing the sleep.</p>
<p>There is a minor complication: if lk is the same lock as p-&gt;lock, then sleep would deadlock with itself if it tried to acquire p-&gt;lock. But if the process calling sleep already holds p-&gt;lock, it doesn’t need to do anything more in order to avoiding missing a concurrent wakeup. This case arises when wait <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L582">(kernel/proc.c:582) </a>calls sleep with p-&gt;lock.</p>
<p>Now that sleep holds p-&gt;lock and no others, it can put the process to sleep by recording the sleep channel, changing the process state to SLEEPING, and calling sched <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L564-L567">(kernel/proc.c:564-567)</a>. In a moment it will be clear why it’s critical that p-&gt;lock is not released (by scheduler) until after the process is marked SLEEPING.</p>
<p>At some point, a process will acquire the condition lock, set the condition that the sleeper   is waiting for, and call wakeup(chan). It’s important that wakeup is called while holding the condition lock1. Wakeup loops over the process table <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L582">(kernel/proc.c:582)</a>. It acquires the p-&gt;lock of each process it inspects, both because it may manipulate that process’s state and because p-&gt;lock ensures that sleep and wakeup do not miss each other. When wakeup finds a process in state SLEEPING with a matching chan, it changes that process’s state to RUNNABLE. The next time the scheduler runs, it will see that the process is ready to be run.</p>
<p>Why do the locking rules for sleep and wakeup ensure a sleeping process won’t miss a wakeup? The sleeping process holds either the condition lock or its own p-&gt;lock or both from a</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image001.gif" alt="img"></td>
</tr>
</tbody></table>
<p>1Strictly speaking it is sufficient if wakeup merely follows the acquire (that is, one could call wakeup after the release).</p>
<p>point before it checks the condition to a point after it is marked SLEEPING. The process calling wakeup holds <em>both</em> of those locks in wakeup’s loop. Thus the waker either makes the condition true before the consuming thread checks the condition; or the waker’s wakeup examines the sleep- ing thread strictly after it has been marked SLEEPING. Then wakeup will see the sleeping process and wake it up (unless something else wakes it up first).</p>
<p>It is sometimes the case that multiple processes are sleeping on the same channel; for example, more than one process reading from a pipe. A single call to wakeup will wake them all up. One of them will run first and acquire the lock that sleep was called with, and (in the case of pipes) read whatever data is waiting in the pipe. The other processes will find that, despite being woken up, there is no data to be read. From their point of view the wakeup was “spurious,” and they must sleep again. For this reason sleep is always called inside a loop that checks the condition.</p>
<p>No harm is done if two uses of sleep/wakeup accidentally choose the same channel: they will see spurious wakeups, but looping as described above will tolerate this problem. Much of the charm of sleep/wakeup is that it is both lightweight (no need to create special data structures to act as sleep channels) and provides a layer of indirection (callers need not know which specific process they are interacting with).</p>
<h1 id="7-7-Code-Pipes"><a href="#7-7-Code-Pipes" class="headerlink" title="7.7     Code: Pipes"></a>7.7     Code: Pipes</h1><p>A more complex example that uses sleep and wakeup to synchronize producers and consumers is xv6’s implementation of pipes. We saw the interface for pipes in Chapter 1: bytes written to one end of a pipe are copied to an in-kernel buffer and then can be read from the other end of the pipe. Future chapters will examine the file descriptor support surrounding pipes, but let’s look now at the implementations of pipewrite and piperead.</p>
<p>Each pipe is represented by a struct pipe, which contains a lock and a data buffer. The fields nread and nwrite count the total number of bytes read from and written to the buffer. The buffer wraps around: the next byte written after buf[PIPESIZE-1] is buf[0]. The counts do not wrap. This convention lets the implementation distinguish a full buffer (nwrite == nread+PIPESIZE) from an empty buffer (nwrite == nread), but it means that indexing into the buffer must use buf[nread % PIPESIZE] instead of just buf[nread] (and similarly for nwrite).</p>
<p>Let’s suppose that calls to piperead and pipewrite happen simultaneously on two different CPUs. Pipewrite <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L77">(kernel/pipe.c:77) </a>begins by acquiring the pipe’s lock, which protects the counts, the data, and their associated invariants. Piperead <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L103">(kernel/pipe.c:103) </a>then tries to acquire the lock too, but cannot. It spins in acquire <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c#L22">(kernel/spinlock.c:22) </a>waiting for the lock. While piperead waits, pipewrite loops over the bytes being written (addr[0..n-1]), adding each to the pipe in turn <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L95">(kernel/pipe.c:95)</a>. During this loop, it could happen that the buffer fills <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L85">(kernel/pipe.c:85)</a>. In this case, pipewrite calls wakeup to alert any sleeping readers to the fact that there is data waiting in the buffer and then sleeps on &amp;pi-&gt;nwrite to wait for a reader to take some bytes out of the buffer. Sleep releases pi-&gt;lock as part of putting pipewrite’s process to sleep.</p>
<p>Now that pi-&gt;lock is available, piperead manages to acquire it and enters its critical sec- tion: it finds that pi-&gt;nread != pi-&gt;nwrite <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L110">(kernel/pipe.c:110) </a>(pipewrite went to sleep be-</p>
<p>cause pi-&gt;nwrite == pi-&gt;nread+PIPESIZE <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L85">(kernel/pipe.c:85)</a>), so it falls through to the for loop, copies data out of the pipe <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L117">(kernel/pipe.c:117)</a>, and increments nread by the number of bytes copied. That many bytes are now available for writing, so piperead calls wakeup <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L124">(ker-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L124">nel/pipe.c:124) </a>to wake any sleeping writers before it returns. Wakeup finds a process sleeping on &amp;pi-&gt;nwrite, the process that was running pipewrite but stopped when the buffer filled. It marks that process as RUNNABLE.</p>
<p>The pipe code uses separate sleep channels for reader and writer (pi-&gt;nread and pi-&gt;nwrite); this might make the system more efficient in the unlikely event that there are lots of readers and writers waiting for the same pipe. The pipe code sleeps inside a loop checking the sleep condition; if there are multiple readers or writers, all but the first process to wake up will see the condition is still false and sleep again.</p>
<h1 id="7-8-Code-Wait-exit-and-kill"><a href="#7-8-Code-Wait-exit-and-kill" class="headerlink" title="7.8     Code: Wait, exit, and kill"></a>7.8     Code: Wait, exit, and kill</h1><p>Sleep and wakeup can be used for many kinds of waiting. An interesting example, introduced in Chapter 1, is the interaction between a child’s exit and its parent’s wait. At the time of the child’s death, the parent may already be sleeping in wait, or may be doing something else; in the latter case, a subsequent call to wait must observe the child’s death, perhaps long after it calls exit. The way that xv6 records the child’s demise until wait observes it is for exit to put the caller into the ZOMBIE state, where it stays until the parent’s wait notices it, changes the child’s state to UNUSED, copies the child’s exit status, and returns the child’s process ID to the parent. If the parent exits before the child, the parent gives the child to the init process, which perpetually calls wait; thus every child has a parent to clean up after it. The main implementation challenge is the possibility of races and deadlock between parent and child wait and exit, as well as exit and exit.</p>
<p>Wait uses the calling process’s p-&gt;lock as the condition lock to avoid lost wakeups, and it acquires that lock at the start <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L398">(kernel/proc.c:398)</a>. Then it scans the process table. If it finds a child in ZOMBIE state, it frees that child’s resources and its proc structure, copies the child’s exit status to the address supplied to wait (if it is not 0), and returns the child’s process ID. If wait finds children but none have exited, it calls sleep to wait for one of them to exit <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L445">(kernel/proc.c:445)</a>, then scans again. Here, the condition lock being released in sleep is the waiting process’s p-&gt;lock, the special case mentioned above. Note that wait often holds two locks; that it acquires its own lock before trying to acquire any child’s lock; and that thus all of xv6 must obey the same locking order (parent, then child) in order to avoid deadlock.</p>
<p>Wait looks at every process’s np-&gt;parent to find its children. It uses np-&gt;parent with- out holding np-&gt;lock, which is a violation of the usual rule that shared variables must be pro- tected by locks. It is possible that np is an ancestor of the current process, in which case acquiring np-&gt;lock could cause a deadlock since that would violate the order mentioned above. Examining np-&gt;parent without a lock seems safe in this case; a process’s parent field is only changed by its parent, so if np-&gt;parent==p is true, the value can’t change unless the current process changes it.</p>
<p>Exit <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L333">(kernel/proc.c:333)</a> records the exit status, frees some resources, gives any children to</p>
<p>the init process, wakes up the parent in case it is in wait, marks the caller as a zombie, and permanently yields the CPU. The final sequence is a little tricky. The exiting process must hold its parent’s lock while it sets its state to ZOMBIE and wakes the parent up, since the parent’s lock is the condition lock that guards against lost wakeups in wait. The child must also hold its own p-&gt;lock, since otherwise the parent might see it in state ZOMBIE and free it while it is still running. The lock acquisition order is important to avoid deadlock: since wait acquires the parent’s lock before the child’s lock, exit must use the same order.</p>
<p>Exit calls a specialized wakeup function, wakeup1, that wakes up only the parent, and only if it is sleeping in wait <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L598">(kernel/proc.c:598)</a>. It may look incorrect for the child to wake up the parent before setting its state to ZOMBIE, but that is safe: although wakeup1 may cause the parent to run, the loop in wait cannot examine the child until the child’s p-&gt;lock is released by scheduler, so wait can’t look at the exiting process until well after exit has set its state to ZOMBIE <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L386">(ker-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L386">nel/proc.c:386)</a>.</p>
<p>While exit allows a process to terminate itself, kill <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L611">(kernel/proc.c:611) </a>lets one process re- quest that another terminate. It would be too complex for kill to directly destroy the victim process, since the victim might be executing on another CPU, perhaps in the middle of a sensitive sequence of updates to kernel data structures. Thus kill does very little: it just sets the victim’s p-&gt;killed and, if it is sleeping, wakes it up. Eventually the victim will enter or leave the kernel, at which point code in usertrap will call exit if p-&gt;killed is set. If the victim is running in user space, it will soon enter the kernel by making a system call or because the timer (or some other device) interrupts.</p>
<p>If the victim process is in sleep, kill’s call to wakeup will cause the victim to return from sleep. This is potentially dangerous because the condition being waiting for may not be true. However, xv6 calls to sleep are always wrapped in a while loop that re-tests the condition after sleep returns. Some calls to sleep also test p-&gt;killed in the loop, and abandon the current activity if it is set. This is only done when such abandonment would be correct. For example, the pipe read and write code returns if the killed flag is set; eventually the code will return back to trap, which will again check the flag and exit.</p>
<p>Some xv6 sleep loops do not check p-&gt;killed because the code is in the middle of a multi- step system call that should be atomic. The virtio driver <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/virtio_disk.c#L242">(kernel/virtio_disk.c:242) </a>is an example: it does not check p-&gt;killed because a disk operation may be one of a set of writes that are all needed in order for the file system to be left in a correct state. A process that is killed while waiting for disk I/O won’t exit until it completes the current system call and usertrap sees the killed flag.</p>
<h1 id="7-9-Real-world"><a href="#7-9-Real-world" class="headerlink" title="7.9     Real world"></a>7.9     Real world</h1><p>The xv6 scheduler implements a simple scheduling policy, which runs each process in turn. This policy is called <em>round robin</em>. Real operating systems implement more sophisticated policies that, for example, allow processes to have priorities. The idea is that a runnable high-priority process will be preferred by the scheduler over a runnable low-priority process. These policies can become complex quickly because there are often competing goals: for example, the operating might also want to guarantee fairness and high throughput. In addition, complex policies may lead to unin-</p>
<p>tended interactions such as <em>priority inversion</em> and <em>convoys</em>. Priority inversion can happen when  a low-priority and high-priority process share a lock, which when acquired by the low-priority process can prevent the high-priority process from making progress. A long convoy of waiting processes can form when many high-priority processes are waiting for a low-priority process that acquires a shared lock; once a convoy has formed it can persist for long time. To avoid these kinds of problems additional mechanisms are necessary in sophisticated schedulers.</p>
<p>Sleep and wakeup are a simple and effective synchronization method, but there are many others. The first challenge in all of them is to avoid the “lost wakeups” problem we saw at the beginning of the chapter. The original Unix kernel’s sleep simply disabled interrupts, which suf- ficed because Unix ran on a single-CPU system. Because xv6 runs on multiprocessors, it adds  an explicit lock to sleep. FreeBSD’s msleep takes the same approach. Plan 9’s sleep uses a callback function that runs with the scheduling lock held just before going to sleep; the function serves as a last-minute check of the sleep condition, to avoid lost wakeups. The Linux kernel’s sleep uses an explicit process queue, called a wait queue, instead of a wait channel; the queue has its own internal lock.</p>
<p>Scanning the entire process list in wakeup for processes with a matching chan is inefficient. A better solution is to replace the chan in both sleep and wakeup with a data structure that holds a list of processes sleeping on that structure, such as Linux’s wait queue. Plan 9’s sleep and wakeup call that structure a rendezvous point or Rendez. Many thread libraries refer to the same structure as a condition variable; in that context, the operations sleep and wakeup are called wait and signal. All of these mechanisms share the same flavor: the sleep condition is protected by some kind of lock dropped atomically during sleep.</p>
<p>The implementation of wakeup wakes up all processes that are waiting on a particular chan- nel, and it might be the case that many processes are waiting for that particular channel. The operating system will schedule all these processes and they will race to check the sleep condition. Processes that behave in this way are sometimes called a <em>thundering herd</em>, and it is best avoided. Most condition variables have two primitives for wakeup: signal, which wakes up one process, and broadcast, which wakes up all waiting processes.</p>
<p>Semaphores are often used for synchronization. The count typically corresponds to something like the number of bytes available in a pipe buffer or the number of zombie children that a process has. Using an explicit count as part of the abstraction avoids the “lost wakeup” problem: there is an explicit count of the number of wakeups that have occurred. The count also avoids the spurious wakeup and thundering herd problems.</p>
<p>Terminating processes and cleaning them up introduces much complexity in xv6. In most oper- ating systems it is even more complex, because, for example, the victim process may be deep inside the kernel sleeping, and unwinding its stack requires much careful programming. Many operating systems unwind the stack using explicit mechanisms for exception handling, such as longjmp. Furthermore, there are other events that can cause a sleeping process to be woken up, even though the event it is waiting for has not happened yet. For example, when a Unix process is sleeping, another process may send a signal to it. In this case, the process will return from the interrupted system call with the value -1 and with the error code set to EINTR. The application can check for these values and decide what to do. Xv6 doesn’t support signals and this complexity doesn’t arise.</p>
<p>Xv6’s support for kill is not entirely satisfactory: there are sleep loops which probably should check for p-&gt;killed. A related problem is that, even for sleep loops that check p-&gt;killed, there is a race between sleep and kill; the latter may set p-&gt;killed and try to wake up the victim just after the victim’s loop checks p-&gt;killed but before it calls sleep. If this problem occurs, the victim won’t notice the p-&gt;killed until the condition it is waiting for occurs. This may be quite a bit later (e.g., when the virtio driver returns a disk block that the victim is waiting for) or never (e.g., if the victim is waiting from input from the console, but the user doesn’t type any input).</p>
<p>A real operating system would find free proc structures with an explicit free list in constant time instead of the linear-time search in allocproc; xv6 uses the linear scan for simplicity.</p>
<h1 id="7-10-Exercises"><a href="#7-10-Exercises" class="headerlink" title="7.10     Exercises"></a>7.10     Exercises</h1><p>\1.   Sleep has to check lk != &amp;p-&gt;lock to avoid a deadlock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L558-L561">(kernel/proc.c:558-561)</a>. Suppose the special case were eliminated by replacing</p>
<p>if(lk != &amp;p-&gt;lock){ acquire(&amp;p-&gt;lock); release(lk);</p>
<p>with</p>
<p>}</p>
<p>release(lk); acquire(&amp;p-&gt;lock);</p>
<p>Doing this would break sleep. How?</p>
<p>\2.   Most process cleanup could be done by either exit or wait. It turns out that exit must be the one to close the open files. Why? The answer involves pipes.</p>
<p>\3.   Implement semaphores in xv6 without using sleep and wakeup (but it is OK to use spin locks). Replace the uses of sleep and wakeup in xv6 with semaphores. Judge the result.</p>
<p>\4.   Fix the race mentioned above between kill and sleep, so that a kill that occurs after the victim’s sleep loop checks p-&gt;killed but before it calls sleep results in the victim abandoning the current system call.</p>
<p>\5.   Design a plan so that every sleep loop checks p-&gt;killed so that, for example, a process that is in the virtio driver can return quickly from the while loop if it is killed by another process.</p>
<p>\6.   Modify xv6 to use only one context switch when switching from one process’s kernel thread to another, rather than switching through the scheduler thread. The yielding thread will need to select the next thread itself and call swtch. The challenges will be to prevent multiple cores from executing the same thread accidentally; to get the locking right; and to avoid deadlocks.</p>
<p>\7.   Modify xv6’s scheduler to use the RISC-V WFI (wait for interrupt) instruction when no processes are runnable. Try to ensure that, any time there are runnable processes waiting to run, no cores are pausing in WFI.</p>
<p>\8.   The lock p-&gt;lock protects many invariants, and when looking at a particular piece of xv6 code that is protected by p-&gt;lock, it can be difficult to figure out which invariant is being enforced. Design a plan that is more clean by splitting p-&gt;lock into several locks.</p>
<p><strong>Chapter 8 File system</strong></p>
<p>The purpose of a file system is to organize and store data. File systems typically support sharing of data among users and applications, as well as <em>persistence</em> so that data is still available after a reboot.</p>
<p>The xv6 file system provides Unix-like files, directories, and pathnames (see Chapter 1), and stores its data on a virtio disk for persistence (see Chapter 4). The file system addresses several challenges:</p>
<p>•   The file system needs on-disk data structures to represent the tree of named directories and files, to record the identities of the blocks that hold each file’s content, and to record which areas of the disk are free.</p>
<p>•   The file system must support <em>crash recovery</em>. That is, if a crash (e.g., power failure) occurs, the file system must still work correctly after a restart. The risk is that a crash might interrupt a sequence of updates and leave inconsistent on-disk data structures (e.g., a block that is both used in a file and marked free).</p>
<p>•   Different processes may operate on the file system at the same time, so the file-system code must coordinate to maintain invariants.</p>
<p>•   Accessing a disk is orders of magnitude slower than accessing memory, so the file system must maintain an in-memory cache of popular blocks.</p>
<p>The rest of this chapter explains how xv6 addresses these challenges.</p>
<h1 id="8-1-Overview"><a href="#8-1-Overview" class="headerlink" title="8.1     Overview"></a>8.1     Overview</h1><p>The xv6 file system implementation is organized in seven layers, shown in Figure 8.1. The disk layer reads and writes blocks on an virtio hard drive. The buffer cache layer caches disk blocks and synchronizes access to them, making sure that only one kernel process at a time can modify the data stored in any particular block. The logging layer allows higher layers to wrap updates  to several blocks in a <em>transaction</em>, and ensures that the blocks are updated atomically in the face</p>
<table>
<thead>
<tr>
<th>File descriptor</th>
</tr>
</thead>
<tbody><tr>
<td>Pathname</td>
</tr>
<tr>
<td>Directory</td>
</tr>
<tr>
<td>Inode</td>
</tr>
<tr>
<td>Logging</td>
</tr>
<tr>
<td>Buﬀer cache     <img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image051.jpg" alt="img">  Disk</td>
</tr>
</tbody></table>
<p>Figure 8.1: Layers of the xv6 file system.</p>
<p>of crashes (i.e., all of them are updated or none). The inode layer provides individual files, each represented as an <em>inode</em> with a unique i-number and some blocks holding the file’s data. The di- rectory layer implements each directory as a special kind of inode whose content is a sequence of directory entries, each of which contains a file’s name and i-number. The pathname layer provides hierarchical path names like /usr/rtm/xv6/fs.c, and resolves them with recursive lookup. The file descriptor layer abstracts many Unix resources (e.g., pipes, devices, files, etc.) using the file system interface, simplifying the lives of application programmers.</p>
<p>The file system must have a plan for where it stores inodes and content blocks on the disk. To do so, xv6 divides the disk into several sections, as Figure 8.2 shows. The file system does not use block 0 (it holds the boot sector). Block 1 is called the <em>superblock</em>; it contains metadata about the file system (the file system size in blocks, the number of data blocks, the number of inodes, and the number of blocks in the log). Blocks starting at 2 hold the log. After the log are the inodes, with multiple inodes per block. After those come bitmap blocks tracking which data blocks are in use. The remaining blocks are data blocks; each is either marked free in the bitmap block, or holds content for a file or directory. The superblock is filled in by a separate program, called mkfs, which builds an initial file system.</p>
<p>The rest of this chapter discusses each layer, starting with the buffer cache. Look out for situa- tions where well-chosen abstractions at lower layers ease the design of higher ones.</p>
<h1 id="8-2-Buffer-cache-layer"><a href="#8-2-Buffer-cache-layer" class="headerlink" title="8.2     Buffer cache layer"></a>8.2     Buffer cache layer</h1><p>The buffer cache has two jobs: (1) synchronize access to disk blocks to ensure that only one copy of a block is in memory and that only one kernel thread at a time uses that copy; (2) cache popular blocks so that they don’t need to be re-read from the slow disk. The code is in bio.c.</p>
<p>The main interface exported by the buffer cache consists of bread and bwrite; the former</p>
<p>obtains a <em>buf</em> containing a copy of a block which can be read or modified in memory, and the latter writes a modified buffer to the appropriate block on the disk. A kernel thread must release a buffer by calling brelse when it is done with it. The buffer cache uses a per-buffer sleep-lock to ensure</p>
<table>
<thead>
<tr>
<th>boot</th>
<th>super</th>
<th>lo</th>
<th>g</th>
<th>in</th>
<th>odes</th>
<th></th>
<th>bit ma</th>
<th>p</th>
<th>data</th>
<th>….</th>
<th>data</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>0    1    2</p>
<p>Figure 8.2: Structure of the xv6 file system.</p>
<p>that only one thread at a time uses each buffer (and thus each disk block); bread returns a locked buffer, and brelse releases the lock.</p>
<p>Let’s return to the buffer cache. The buffer cache has a fixed number of buffers to hold disk blocks, which means that if the file system asks for a block that is not already in the cache, the buffer cache must recycle a buffer currently holding some other block. The buffer cache recycles the least recently used buffer for the new block. The assumption is that the least recently used buffer is the one least likely to be used again soon.</p>
<h1 id="8-3-Code-Buffer-cache"><a href="#8-3-Code-Buffer-cache" class="headerlink" title="8.3     Code: Buffer cache"></a>8.3     Code: Buffer cache</h1><p>The buffer cache is a doubly-linked list of buffers. The function binit, called by main <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/main.c#L27">(kernel/-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/main.c#L27">main.c:27)</a>, initializes the list with the NBUF buffers in the static array buf <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L43-L52">(kernel/bio.c:43-52)</a>. All other access to the buffer cache refer to the linked list via bcache.head, not the buf array.</p>
<p>A buffer has two state fields associated with it. The field valid indicates that the buffer con- tains a copy of the block. The field disk indicates that the buffer content has been handed to the disk, which may change the buffer (e.g., write data from the disk into data).</p>
<p>Bread <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L93">(kernel/bio.c:93) </a>calls bget to get a buffer for the given sector <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L97">(kernel/bio.c:97)</a>. If the buffer needs to be read from disk, bread calls virtio_disk_rw to do that before returning the buffer.</p>
<p>Bget <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L59">(kernel/bio.c:59) </a>scans the buffer list for a buffer with the given device and sector numbers <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L65-L73">(kernel/bio.c:65-73)</a>. If there is such a buffer, bget acquires the sleep-lock for the buffer. Bget then returns the locked buffer.</p>
<p>If there is no cached buffer for the given sector, bget must make one, possibly reusing a buffer that held a different sector. It scans the buffer list a second time, looking for a buffer that is not in use (b-&gt;refcnt = 0); any such buffer can be used. Bget edits the buffer metadata to record the new device and sector number and acquires its sleep-lock. Note that the assignment b-&gt;valid = 0 ensures that bread will read the block data from disk rather than incorrectly using the buffer’s previous contents.</p>
<p>It is important that there is at most one cached buffer per disk sector, to ensure that readers see writes, and because the file system uses locks on buffers for synchronization. Bget ensures this invariant by holding the bache.lock continuously from the first loop’s check of whether the block is cached through the second loop’s declaration that the block is now cached (by setting dev, blockno, and refcnt). This causes the check for a block’s presence and (if not present) the designation of a buffer to hold the block to be atomic.</p>
<p>It is safe for bget to acquire the buffer’s sleep-lock outside of the bcache.lock critical section, since the non-zero b-&gt;refcnt prevents the buffer from being re-used for a different</p>
<p>disk block. The sleep-lock protects reads and writes of the block’s buffered content, while the</p>
<p>bcache.lock protects information about which blocks are cached.</p>
<p>If all the buffers are busy, then too many processes are simultaneously executing file system calls; bget panics. A more graceful response might be to sleep until a buffer became free, though there would then be a possibility of deadlock.</p>
<p>Once bread has read the disk (if needed) and returned the buffer to its caller, the caller has exclusive use of the buffer and can read or write the data bytes. If the caller does modify the buffer, it must call bwrite to write the changed data to disk before releasing the buffer. Bwrite <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L107">(kernel/bio.c:107) </a>calls virtio_disk_rw to talk to the disk hardware.</p>
<p>When the caller is done with a buffer, it must call brelse to release it. (The name brelse, a shortening of b-release, is cryptic but worth learning: it originated in Unix and is used in BSD, Linux, and Solaris too.) Brelse <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L117">(kernel/bio.c:117) </a>releases the sleep-lock and moves the buffer to the front of the linked list <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L128-L133">(kernel/bio.c:128-133)</a>. Moving the buffer causes the list to be ordered by how recently the buffers were used (meaning released): the first buffer in the list is the most recently used, and the last is the least recently used. The two loops in bget take advantage of this: the scan for an existing buffer must process the entire list in the worst case, but checking the most recently used buffers first (starting at bcache.head and following next pointers) will reduce scan time when there is good locality of reference. The scan to pick a buffer to reuse picks the least recently used buffer by scanning backward (following prev pointers).</p>
<h1 id="8-4-Logging-layer"><a href="#8-4-Logging-layer" class="headerlink" title="8.4     Logging layer"></a>8.4     Logging layer</h1><p>One of the most interesting problems in file system design is crash recovery. The problem arises because many file-system operations involve multiple writes to the disk, and a crash after a subset of the writes may leave the on-disk file system in an inconsistent state. For example, suppose   a crash occurs during file truncation (setting the length of a file to zero and freeing its content blocks). Depending on the order of the disk writes, the crash may either leave an inode with a reference to a content block that is marked free, or it may leave an allocated but unreferenced content block.</p>
<p>The latter is relatively benign, but an inode that refers to a freed block is likely to cause serious problems after a reboot. After reboot, the kernel might allocate that block to another file, and now we have two different files pointing unintentionally to the same block. If xv6 supported multiple users, this situation could be a security problem, since the old file’s owner would be able to read and write blocks in the new file, owned by a different user.</p>
<p>Xv6 solves the problem of crashes during file-system operations with a simple form of logging. An xv6 system call does not directly write the on-disk file system data structures. Instead, it places a description of all the disk writes it wishes to make in a <em>log</em> on the disk. Once the system call has logged all of its writes, it writes a special <em>commit</em> record to the disk indicating that the log contains a complete operation. At that point the system call copies the writes to the on-disk file system data structures. After those writes have completed, the system call erases the log on disk.</p>
<p>If the system should crash and reboot, the file-system code recovers from the crash as follows, before running any processes. If the log is marked as containing a complete operation, then the</p>
<p>recovery code copies the writes to where they belong in the on-disk file system. If the log is not marked as containing a complete operation, the recovery code ignores the log. The recovery code finishes by erasing the log.</p>
<p>Why does xv6’s log solve the problem of crashes during file system operations? If the crash occurs before the operation commits, then the log on disk will not be marked as complete, the re- covery code will ignore it, and the state of the disk will be as if the operation had not even started. If the crash occurs after the operation commits, then recovery will replay all of the operation’s writes, perhaps repeating them if the operation had started to write them to the on-disk data structure. In either case, the log makes operations atomic with respect to crashes: after recovery, either all of the operation’s writes appear on the disk, or none of them appear.</p>
<h1 id="8-5-Log-design"><a href="#8-5-Log-design" class="headerlink" title="8.5     Log design"></a>8.5     Log design</h1><p>The log resides at a known fixed location, specified in the superblock. It consists of a header block followed by a sequence of updated block copies (“logged blocks”). The header block contains an array of sector numbers, one for each of the logged blocks, and the count of log blocks. The count in the header block on disk is either zero, indicating that there is no transaction in the log, or non- zero, indicating that the log contains a complete committed transaction with the indicated number of logged blocks. Xv6 writes the header block when a transaction commits, but not before, and sets the count to zero after copying the logged blocks to the file system. Thus a crash midway through a transaction will result in a count of zero in the log’s header block; a crash after a commit will result in a non-zero count.</p>
<p>Each system call’s code indicates the start and end of the sequence of writes that must be atomic with respect to crashes. To allow concurrent execution of file-system operations by different pro- cesses, the logging system can accumulate the writes of multiple system calls into one transaction. Thus a single commit may involve the writes of multiple complete system calls. To avoid splitting a system call across transactions, the logging system only commits when no file-system system calls are underway.</p>
<p>The idea of committing several transactions together is known as <em>group commit</em>. Group commit reduces the number of disk operations because it amortizes the fixed cost of a commit over multiple operations. Group commit also hands the disk system more concurrent writes at the same time, perhaps allowing the disk to write them all during a single disk rotation. Xv6’s virtio driver doesn’t support this kind of <em>batching</em>, but xv6’s file system design allows for it.</p>
<p>Xv6 dedicates a fixed amount of space on the disk to hold the log. The total number of blocks written by the system calls in a transaction must fit in that space. This has two consequences.  No single system call can be allowed to write more distinct blocks than there is space in the log. This is not a problem for most system calls, but two of them can potentially write many blocks: write and unlink. A large file write may write many data blocks and many bitmap blocks as well as an inode block; unlinking a large file might write many bitmap blocks and an inode. Xv6’s write system call breaks up large writes into multiple smaller writes that fit in the log, and unlink doesn’t cause problems because in practice the xv6 file system uses only one bitmap block. The other consequence of limited log space is that the logging system cannot allow a system call to</p>
<p>start unless it is certain that the system call’s writes will fit in the space remaining in the log.</p>
<h1 id="8-6-Code-logging"><a href="#8-6-Code-logging" class="headerlink" title="8.6     Code: logging"></a>8.6     Code: logging</h1><p>A typical use of the log in a system call looks like this:</p>
<p>begin_op();</p>
<p>…</p>
<p>bp = bread(…);</p>
<p>bp-&gt;data[…] = …; log_write(bp);</p>
<p>…</p>
<p>end_op();</p>
<p>begin_op <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/log.c#L126">(kernel/log.c:126)</a> waits until the logging system is not currently committing, and until there is enough unreserved log space to hold the writes from this call. log.outstanding</p>
<p>counts the number of system calls that have reserved log space; the total reserved space is log.outstanding times MAXOPBLOCKS. Incrementing log.outstanding both reserves space and prevents a com-</p>
<p>mit from occuring during this system call. The code conservatively assumes that each system call might write up to MAXOPBLOCKS distinct blocks.</p>
<p>log_write <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/log.c#L214">(kernel/log.c:214) </a>acts as a proxy for bwrite. It records the block’s sector number</p>
<p>in memory, reserving it a slot in the log on disk, and pins the buffer in the block cache to prevent the block cache from evicting it. The block must stay in the cache until committed: until then, the cached copy is the only record of the modification; it cannot be written to its place on disk until after commit; and other reads in the same transaction must see the modifications. log_write notices when a block is written multiple times during a single transaction, and allocates that block the same slot in the log. This optimization is often called <em>absorption</em>. It is common that, for example, the disk block containing inodes of several files is written several times within a transaction. By absorbing several disk writes into one, the file system can save log space and can achieve better performance because only one copy of the disk block must be written to disk.</p>
<p>end_op <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/log.c#L146">(kernel/log.c:146) </a>first decrements the count of outstanding system calls. If the count is now zero, it commits the current transaction by calling commit(). There are four stages in this process. write_log() <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/log.c#L178">(kernel/log.c:178) </a>copies each block modified in the transaction from the buffer cache to its slot in the log on disk. write_head() <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/log.c#L102">(kernel/log.c:102) </a>writes the header block to disk: this is the commit point, and a crash after the write will result in recovery replaying the transaction’s writes from the log. install_trans <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/log.c#L69">(kernel/log.c:69) </a>reads each block from the log and writes it to the proper place in the file system. Finally end_op writes the log header with a count of zero; this has to happen before the next transaction starts writing logged blocks, so that a crash doesn’t result in recovery using one transaction’s header with the subsequent transaction’s logged blocks.</p>
<p>recover_from_log <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/log.c#L116">(kernel/log.c:116) </a>is called from initlog <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/log.c#L55">(kernel/log.c:55)</a>, which is called from fsinit<a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L42">(kernel/fs.c:42)</a> during boot before the first user process runs <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L539">(kernel/proc.c:539)</a>. It reads the log header, and mimics the actions of end_op if the header indicates that the log con- tains a committed transaction.</p>
<p>An example use of the log occurs in filewrite <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L135">(kernel/file.c:135)</a>. The transaction looks like this:</p>
<p>begin_op(); ilock(f-&gt;ip);</p>
<p>r = writei(f-&gt;ip, …); iunlock(f-&gt;ip); end_op();</p>
<p>This code is wrapped in a loop that breaks up large writes into individual transactions of just a few sectors at a time, to avoid overflowing the log. The call to writei writes many blocks as part of this transaction: the file’s inode, one or more bitmap blocks, and some data blocks.</p>
<h1 id="8-7-Code-Block-allocator"><a href="#8-7-Code-Block-allocator" class="headerlink" title="8.7     Code: Block allocator"></a>8.7     Code: Block allocator</h1><p>File and directory content is stored in disk blocks, which must be allocated from a free pool. xv6’s block allocator maintains a free bitmap on disk, with one bit per block. A zero bit indicates that the corresponding block is free; a one bit indicates that it is in use. The program mkfs sets the bits corresponding to the boot sector, superblock, log blocks, inode blocks, and bitmap blocks.</p>
<p>The block allocator provides two functions: balloc allocates a new disk block, and bfree frees a block. Balloc The loop in balloc at <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L71">(kernel/fs.c:71)</a> considers every block, starting at block 0 up to sb.size, the number of blocks in the file system. It looks for a block whose bitmap bit is zero, indicating that it is free. If balloc finds such a block, it updates the bitmap and returns the block. For efficiency, the loop is split into two pieces. The outer loop reads each block of bitmap bits. The inner loop checks all BPB bits in a single bitmap block. The race that might occur if two processes try to allocate a block at the same time is prevented by the fact that the buffer cache only lets one process use any one bitmap block at a time.</p>
<p>Bfree <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L90">(kernel/fs.c:90) </a>finds the right bitmap block and clears the right bit. Again the exclusive use implied by bread and brelse avoids the need for explicit locking.</p>
<p>As with much of the code described in the remainder of this chapter, balloc and bfree must be called inside a transaction.</p>
<h1 id="8-8-Inode-layer"><a href="#8-8-Inode-layer" class="headerlink" title="8.8     Inode layer"></a>8.8     Inode layer</h1><p>The term <em>inode</em> can have one of two related meanings. It might refer to the on-disk data structure containing a file’s size and list of data block numbers. Or “inode” might refer to an in-memory inode, which contains a copy of the on-disk inode as well as extra information needed within the kernel.</p>
<p>The on-disk inodes are packed into a contiguous area of disk called the inode blocks. Every inode is the same size, so it is easy, given a number n, to find the nth inode on the disk. In fact, this number n, called the inode number or i-number, is how inodes are identified in the implementation. The on-disk inode is defined by a struct dinode <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.h#L32">(kernel/fs.h:32)</a>. The type field distin- guishes between files, directories, and special files (devices). A type of zero indicates that an on-</p>
<p>disk inode is free. The nlink field counts the number of directory entries that refer to this inode, in order to recognize when the on-disk inode and its data blocks should be freed. The size field records the number of bytes of content in the file. The addrs array records the block numbers of the disk blocks holding the file’s content.</p>
<p>The kernel keeps the set of active inodes in memory; struct inode <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.h#L17">(kernel/file.h:17) </a>is the in-memory copy of a struct dinode on disk. The kernel stores an inode in memory only if there are C pointers referring to that inode. The ref field counts the number of C pointers referring to the in-memory inode, and the kernel discards the inode from memory if the reference count drops to zero. The iget and iput functions acquire and release pointers to an inode, modifying the reference count. Pointers to an inode can come from file descriptors, current working directories, and transient kernel code such as exec.</p>
<p>There are four lock or lock-like mechanisms in xv6’s inode code. icache.lock protects the invariant that an inode is present in the cache at most once, and the invariant that a cached inode’s ref field counts the number of in-memory pointers to the cached inode. Each in-memory inode has a lock field containing a sleep-lock, which ensures exclusive access to the inode’s fields (such as file length) as well as to the inode’s file or directory content blocks. An inode’s ref, if it is greater than zero, causes the system to maintain the inode in the cache, and not re-use the cache entry for a different inode. Finally, each inode contains a nlink field (on disk and copied in memory if it is cached) that counts the number of directory entries that refer to a file; xv6 won’t free an inode if its link count is greater than zero.</p>
<p>A struct inode pointer returned by iget() is guaranteed to be valid until the corresponding call to iput(); the inode won’t be deleted, and the memory referred to by the pointer won’t be re-used for a different inode. iget() provides non-exclusive access to an inode, so that there can be many pointers to the same inode. Many parts of the file-system code depend on this behavior of iget(), both to hold long-term references to inodes (as open files and current directories) and to prevent races while avoiding deadlock in code that manipulates multiple inodes (such as pathname lookup).</p>
<p>The struct inode that iget returns may not have any useful content. In order to ensure it holds a copy of the on-disk inode, code must call ilock. This locks the inode (so that no other process can ilock it) and reads the inode from the disk, if it has not already been read. iunlock releases the lock on the inode. Separating acquisition of inode pointers from locking helps avoid deadlock in some situations, for example during directory lookup. Multiple processes can hold a C pointer to an inode returned by iget, but only one process can lock the inode at a time.</p>
<p>The inode cache only caches inodes to which kernel code or data structures hold C pointers. Its main job is really synchronizing access by multiple processes; caching is secondary. If an inode is used frequently, the buffer cache will probably keep it in memory if it isn’t kept by the inode cache. The inode cache is <em>write-through</em>, which means that code that modifies a cached inode must immediately write it to disk with iupdate.</p>
<h1 id="8-9-Code-Inodes"><a href="#8-9-Code-Inodes" class="headerlink" title="8.9     Code: Inodes"></a>8.9     Code: Inodes</h1><p>To allocate a new inode (for example, when creating a file), xv6 calls ialloc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L196">(kernel/fs.c:196)</a>. Ialloc is similar to balloc: it loops over the inode structures on the disk, one block at a time, looking for one that is marked free. When it finds one, it claims it by writing the new type to the disk and then returns an entry from the inode cache with the tail call to iget <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L210">(kernel/fs.c:210)</a>. The correct operation of ialloc depends on the fact that only one process at a time can be holding a reference to bp: ialloc can be sure that some other process does not simultaneously see that the inode is available and try to claim it.</p>
<p>Iget <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L243">(kernel/fs.c:243) </a>looks through the inode cache for an active entry (ip-&gt;ref &gt; 0) with the desired device and inode number. If it finds one, it returns a new reference to that inode <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L252-L256">(kernel/fs.c:252-256)</a>. As iget scans, it records the position of the first empty slot <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L257-L258">(kernel/fs.c:257-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L257-L258">258)</a>, which it uses if it needs to allocate a cache entry.</p>
<p>Code must lock the inode using ilock before reading or writing its metadata or content. Ilock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L289">(kernel/fs.c:289) </a>uses a sleep-lock for this purpose. Once ilock has exclusive access to the inode, it reads the inode from disk (more likely, the buffer cache) if needed. The function iunlock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L317">(kernel/fs.c:317) </a>releases the sleep-lock, which may cause any processes sleeping to be woken up.</p>
<p>Iput <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L333">(kernel/fs.c:333)</a> releases a C pointer to an inode by decrementing the reference count <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L356">(kernel/fs.c:356)</a>. If this is the last reference, the inode’s slot in the inode cache is now free and can be re-used for a different inode.</p>
<p>If iput sees that there are no C pointer references to an inode and that the inode has no links to it (occurs in no directory), then the inode and its data blocks must be freed. Iput calls itrunc to truncate the file to zero bytes, freeing the data blocks; sets the inode type to 0 (unallocated); and writes the inode to disk <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L338">(kernel/fs.c:338)</a>.</p>
<p>The locking protocol in iput in the case in which it frees the inode deserves a closer look. One danger is that a concurrent thread might be waiting in ilock to use this inode (e.g., to read a file or list a directory), and won’t be prepared to find that the inode is not longer allocated. This can’t happen because there is no way for a system call to get a pointer to a cached inode if it has no links to it and ip-&gt;ref is one. That one reference is the reference owned by the thread calling iput. It’s true that iput checks that the reference count is one outside of its icache.lock critical section, but at that point the link count is known to be zero, so no thread will try to acquire a new reference. The other main danger is that a concurrent call to ialloc might choose the same inode that iput is freeing. This can only happen after the iupdate writes the disk so that the inode has type zero. This race is benign; the allocating thread will politely wait to acquire the inode’s sleep-lock before reading or writing the inode, at which point iput is done with it.</p>
<p>iput() can write to the disk. This means that any system call that uses the file system may</p>
<p>write the disk, because the system call may be the last one having a reference to the file. Even calls like read() that appear to be read-only, may end up calling iput(). This, in turn, means that even read-only system calls must be wrapped in transactions if they use the file system.</p>
<p>There is a challenging interaction between iput() and crashes. iput() doesn’t truncate a file immediately when the link count for the file drops to zero, because some process might still hold a reference to the inode in memory: a process might still be reading and writing to the file, because it successfully opened it. But, if a crash happens before the last process closes the file descriptor</p>
<p><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image056.gif" alt="img">dinode</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="file:///C:/Users/hxy/AppData/Local/Packages/oice_16_974fa576_32c1d314_f79/AC/Temp/msohtmlclip1/01/clip_image058.gif" alt="img"></td>
</tr>
</tbody></table>
<p>…</p>
<p>Figure 8.3: The representation of a file on disk.</p>
<p>for the file, then the file will be marked allocated on disk but no directory entry will point to it.</p>
<p>File systems handle this case in one of two ways. The simple solution is that on recovery, after reboot, the file system scans the whole file system for files that are marked allocated, but have no directory entry pointing to them. If any such file exists, then it can free those files.</p>
<p>The second solution doesn’t require scanning the file system. In this solution, the file system records on disk (e.g., in the super block) the inode inumber of a file whose link count drops to zero but whose reference count isn’t zero. If the file system removes the file when its reference counts reaches 0, then it updates the on-disk list by removing that inode from the list. On recovery, the file system frees any file in the list.</p>
<p>Xv6 implements neither solution, which means that inodes may be marked allocated on disk, even though they are not in use anymore. This means that over time xv6 runs the risk that it may run out of disk space.</p>
<h1 id="8-10-Code-Inode-content"><a href="#8-10-Code-Inode-content" class="headerlink" title="8.10     Code: Inode content"></a>8.10     Code: Inode content</h1><p>The on-disk inode structure, struct dinode, contains a size and an array of block numbers (see Figure 8.3). The inode data is found in the blocks listed in the dinode ’s addrs array. The first NDIRECT blocks of data are listed in the first NDIRECT entries in the array; these blocks are called</p>
<p><em>direct blocks</em>. The next NINDIRECT blocks of data are listed not in the inode but in a data block called the <em>indirect block</em>. The last entry in the addrs array gives the address of the indirect block. Thus the first 12 kB ( NDIRECT x BSIZE) bytes of a file can be loaded from blocks listed in the inode, while the next 256 kB ( NINDIRECT x BSIZE) bytes can only be loaded after consulting the indirect block. This is a good on-disk representation but a complex one for clients. The function bmap manages the representation so that higher-level routines such as readi and writei, which we will see shortly. Bmap returns the disk block number of the bn’th data block for the inode ip. If ip does not have such a block yet, bmap allocates one.</p>
<p>The function bmap <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L378">(kernel/fs.c:378)</a> begins by picking off the easy case: the first NDIRECT blocks are listed in the inode itself <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L383-L387">(kernel/fs.c:383-387)</a>. The next NINDIRECT blocks are listed in the indirect block at ip-&gt;addrs[NDIRECT]. Bmap reads the indirect block <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L394">(kernel/fs.c:394) </a>and then reads a block number from the right position within the block <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L395">(kernel/fs.c:395)</a>. If the block number exceeds NDIRECT+NINDIRECT, bmap panics; writei contains the check that prevents this from happening <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L490">(kernel/fs.c:490)</a>.</p>
<p>Bmap allocates blocks as needed. An ip-&gt;addrs[] or indirect entry of zero indicates that no block is allocated. As bmap encounters zeros, it replaces them with the numbers of fresh blocks, allocated on demand <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L384-L385">(kernel/fs.c:384-385) </a><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L392-L393">(kernel/fs.c:392-393)</a>.</p>
<p>itrunc frees a file’s blocks, resetting the inode’s size to zero. Itrunc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L410">(kernel/fs.c:410) </a>starts by freeing the direct blocks <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L416-L421">(kernel/fs.c:416-421)</a>, then the ones listed in the indirect block <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L426-L429">(kernel/fs.c:426-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L426-L429">429)</a>, and finally the indirect block itself <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L431-L432">(kernel/fs.c:431-432)</a>.</p>
<p>Bmap makes it easy for readi and writei to get at an inode’s data. Readi <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L456">(kernel/fs.c:456)</a> starts by making sure that the offset and count are not beyond the end of the file. Reads that  start beyond the end of the file return an error <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L461-L462">(kernel/fs.c:461-462)</a> while reads that start at or cross the end of the file return fewer bytes than requested <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L463-L464">(kernel/fs.c:463-464)</a>. The main loop processes each block of the file, copying data from the buffer into dst <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L466-L474">(kernel/fs.c:466-474)</a>. writei <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L483">(kernel/fs.c:483) </a>is identical to readi, with three exceptions: writes that start at or cross the end of the file grow the file, up to the maximum file size <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L490-L491">(kernel/fs.c:490-491)</a>; the loop copies data into the buffers instead of out <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L36">(kernel/fs.c:36)</a>; and if the write has extended the file, writei must update its size <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L504-L511">(kernel/fs.c:504-511)</a>.</p>
<p>Both readi and writei begin by checking for ip-&gt;type == T_DEV. This case handles spe- cial devices whose data does not live in the file system; we will return to this case in the file descriptor layer.</p>
<p>The function stati <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L442">(kernel/fs.c:442) </a>copies inode metadata into the stat structure, which is exposed to user programs via the stat system call.</p>
<h1 id="8-11-Code-directory-layer"><a href="#8-11-Code-directory-layer" class="headerlink" title="8.11     Code: directory layer"></a>8.11     Code: directory layer</h1><p>A directory is implemented internally much like a file. Its inode has type T_DIR and its data is a sequence of directory entries. Each entry is a struct dirent <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.h#L56">(kernel/fs.h:56)</a>, which contains a name and an inode number. The name is at most DIRSIZ (14) characters; if shorter, it is terminated by a NUL (0) byte. Directory entries with inode number zero are free.</p>
<p>The function dirlookup <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L527">(kernel/fs.c:527) </a>searches a directory for an entry with the given name.</p>
<p>If it finds one, it returns a pointer to the corresponding inode, unlocked, and sets *poff to the byte offset of the entry within the directory, in case the caller wishes to edit it. If dirlookup finds an entry with the right name, it updates *poff and returns an unlocked inode obtained via iget. Dirlookup is the reason that iget returns unlocked inodes. The caller has locked dp, so if the lookup was for ., an alias for the current directory, attempting to lock the inode before returning would try to re-lock dp and deadlock. (There are more complicated deadlock scenarios involving multiple processes and .., an alias for the parent directory; . is not the only problem.) The caller can unlock dp and then lock ip, ensuring that it only holds one lock at a time.</p>
<p>The function dirlink <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L554">(kernel/fs.c:554) </a>writes a new directory entry with the given name and in- ode number into the directory dp. If the name already exists, dirlink returns an error <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L560-L564">(kernel/fs.c:560-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L560-L564">564)</a>. The main loop reads directory entries looking for an unallocated entry. When it finds one, it stops the loop early <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L538-L539">(kernel/fs.c:538-539)</a>, with off set to the offset of the available entry. Other- wise, the loop ends with off set to dp-&gt;size. Either way, dirlink then adds a new entry to the directory by writing at offset off <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L574-L577">(kernel/fs.c:574-577)</a>.</p>
<h1 id="8-12-Code-Path-names"><a href="#8-12-Code-Path-names" class="headerlink" title="8.12     Code: Path names"></a>8.12     Code: Path names</h1><p>Path name lookup involves a succession of calls to dirlookup, one for each path component. Namei <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L661">(kernel/fs.c:661) </a>evaluates path and returns the corresponding inode. The function nameiparent is a variant: it stops before the last element, returning the inode of the parent directory and copying</p>
<p>the final element into name. Both call the generalized function namex to do the real work.</p>
<p>Namex <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L626">(kernel/fs.c:626) </a>starts by deciding where the path evaluation begins. If the path begins with a slash, evaluation begins at the root; otherwise, the current directory <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L630-L633">(kernel/fs.c:630-633)</a>. Then it uses skipelem to consider each element of the path in turn <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L635">(kernel/fs.c:635)</a>. Each iteration of the loop must look up name in the current inode ip. The iteration begins by locking ip and checking that it is a directory. If not, the lookup fails <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L636-L640">(kernel/fs.c:636-640)</a>. (Locking ip is necessary not because ip-&gt;type can change underfoot—it can’t—but because until ilock runs, ip-&gt;type is not guaranteed to have been loaded from disk.) If the call is nameiparent and this is the last path element, the loop stops early, as per the definition of nameiparent; the final path element has already been copied into name, so namex need only return the unlocked ip <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L641-L645">(kernel/fs.c:641-645)</a>. Finally, the loop looks for the path element using dirlookup and prepares for the next iteration by setting ip = next <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L646-L651">(kernel/fs.c:646-651)</a>. When the loop runs out of path elements, it returns ip. The procedure namex may take a long time to complete: it could involve several disk opera- tions to read inodes and directory blocks for the directories traversed in the pathname (if they are not in the buffer cache). Xv6 is carefully designed so that if an invocation of namex by one kernel thread is blocked on a disk I/O, another kernel thread looking up a different pathname can pro- ceed concurrently. Namex locks each directory in the path separately so that lookups in different</p>
<p>directories can proceed in parallel.</p>
<p>This concurrency introduces some challenges. For example, while one kernel thread is looking up a pathname another kernel thread may be changing the directory tree by unlinking a directory. A potential risk is that a lookup may be searching a directory that has been deleted by another kernel thread and its blocks have been re-used for another directory or file.</p>
<p>Xv6 avoids such races. For example, when executing dirlookup in namex, the lookup thread holds the lock on the directory and dirlookup returns an inode that was obtained using iget. Iget increases the reference count of the inode. Only after receiving the inode from dirlookup does namex release the lock on the directory. Now another thread may unlink the inode from the directory but xv6 will not delete the inode yet, because the reference count of the inode is still larger than zero.</p>
<p>Another risk is deadlock. For example, next points to the same inode as ip when looking up “.”. Locking next before releasing the lock on ip would result in a deadlock. To avoid this deadlock, namex unlocks the directory before obtaining a lock on next. Here again we see why the separation between iget and ilock is important.</p>
<h1 id="8-13-File-descriptor-layer"><a href="#8-13-File-descriptor-layer" class="headerlink" title="8.13     File descriptor layer"></a>8.13     File descriptor layer</h1><p>A cool aspect of the Unix interface is that most resources in Unix are represented as files, including devices such as the console, pipes, and of course, real files. The file descriptor layer is the layer that achieves this uniformity.</p>
<p>Xv6 gives each process its own table of open files, or file descriptors, as we saw in Chapter 1. Each open file is represented by a struct file <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.h#L1">(kernel/file.h:1)</a>, which is a wrapper around either an inode or a pipe, plus an I/O offset. Each call to open creates a new open file (a new struct file): if multiple processes open the same file independently, the different instances will have different I/O offsets. On the other hand, a single open file (the same struct file) can appear multiple times in one process’s file table and also in the file tables of multiple processes. This would happen if one process used open to open the file and then created aliases using dup or shared it with a child using fork. A reference count tracks the number of references to a particular open file. A file can be open for reading or writing or both. The readable and writable fields track this.</p>
<p>All the open files in the system are kept in a global file table, the ftable. The file table  has functions to allocate a file (filealloc), create a duplicate reference (filedup), release a reference (fileclose), and read and write data (fileread and filewrite).</p>
<p>The first three follow the now-familiar form. Filealloc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L30">(kernel/file.c:30) </a>scans the file table for an unreferenced file (f-&gt;ref == 0) and returns a new reference; filedup <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L48">(kernel/file.c:48) </a>incre- ments the reference count; and fileclose <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L60">(kernel/file.c:60) </a>decrements it. When a file’s reference count reaches zero, fileclose releases the underlying pipe or inode, according to the type.</p>
<p>The functions filestat, fileread, and filewrite implement the stat, read, and write operations on files. Filestat <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L88">(kernel/file.c:88) </a>is only allowed on inodes and calls stati. Fileread and filewrite check that the operation is allowed by the open mode and then pass the call through to either the pipe or inode implementation. If the file represents an inode, fileread and filewrite use the I/O offset as the offset for the operation and then advance it <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L122-L123">(kernel/file.c:122-</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L122-L123">123) </a><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L153-L154">(kernel/file.c:153-154)</a>. Pipes have no concept of offset. Recall that the inode functions require the caller to handle locking <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L94-L96">(kernel/file.c:94-96) </a><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L121-L124">(kernel/file.c:121-124) </a><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/file.c#L163-L166">(kernel/file.c:163-166)</a>. The in- ode locking has the convenient side effect that the read and write offsets are updated atomically, so that multiple writing to the same file simultaneously cannot overwrite each other’s data, though</p>
<p>their writes may end up interlaced.</p>
<h1 id="8-14-Code-System-calls"><a href="#8-14-Code-System-calls" class="headerlink" title="8.14     Code: System calls"></a>8.14     Code: System calls</h1><p>With the functions that the lower layers provide the implementation of most system calls is trivial (see <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c">(kernel/sysfile.c)</a>). There are a few calls that deserve a closer look.</p>
<p>The functions sys_link and sys_unlink edit directories, creating or removing references to inodes. They are another good example of the power of using transactions. Sys_link <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L120">(kernel/sys-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L120">file.c:120) </a>begins by fetching its arguments, two strings old and new <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L125">(kernel/sysfile.c:125)</a>. Assuming old exists and is not a directory <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L129-L132">(kernel/sysfile.c:129-132)</a>, sys_link increments its ip-&gt;nlink count. Then sys_link calls nameiparent to find the parent directory and final path element of new <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L145">(kernel/sysfile.c:145) </a>and creates a new directory entry pointing at old ’s inode <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L148">(kernel/sys-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L148">file.c:148)</a>. The new parent directory must exist and be on the same device as the existing inode: inode numbers only have a unique meaning on a single disk. If an error like this occurs, sys_link must go back and decrement ip-&gt;nlink.</p>
<p>Transactions simplify the implementation because it requires updating multiple disk blocks, but we don’t have to worry about the order in which we do them. They either will all succeed or none. For example, without transactions, updating ip-&gt;nlink before creating a link, would put the file system temporarily in an unsafe state, and a crash in between could result in havoc. With transactions we don’t have to worry about this.</p>
<p>Sys_link creates a new name for an existing inode. The function create <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L242">(kernel/sysfile.c:242)</a> creates a new name for a new inode. It is a generalization of the three file creation system calls: open with the O_CREATE flag makes a new ordinary file, mkdir makes a new directory, and mkdev makes a new device file. Like sys_link, create starts by caling nameiparent to get the inode of the parent directory. It then calls dirlookup to check whether the name already exists <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L252">(kernel/sysfile.c:252)</a>. If the name does exist, create’s behavior depends on which system call it is being used for: open has different semantics from mkdir and mkdev. If create is being used on behalf of open (type == T_FILE) and the name that exists is itself a regular file, then open treats that as a success, so create does too <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L256">(kernel/sysfile.c:256)</a>. Otherwise, it is an error <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L257-L258">(kernel/sysfile.c:257-258)</a>. If the name does not already exist, create now allocates a new inode with ialloc <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L261">(kernel/sysfile.c:261)</a>. If the new inode is a directory, create initializes it with . and</p>
<p>.. entries. Finally, now that the data is initialized properly, create can link it into the parent directory <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L274">(kernel/sysfile.c:274)</a>. Create, like sys_link, holds two inode locks simultaneously: ip and dp. There is no possibility of deadlock because the inode ip is freshly allocated: no other process in the system will hold ip ’s lock and then try to lock dp.</p>
<p>Using create, it is easy to implement sys_open, sys_mkdir, and sys_mknod. Sys_open <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L287">(kernel/sysfile.c:287) </a>is the most complex, because creating a new file is only a small part of what it can do. If open is passed the O_CREATE flag, it calls create <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L301">(kernel/sysfile.c:301)</a>. Otherwise, it calls namei <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L307">(kernel/sysfile.c:307)</a>. Create returns a locked inode, but namei does not, so sys_open must lock the inode itself. This provides a convenient place to check that directories are only opened for reading, not writing. Assuming the inode was obtained one way or the other, sys_open allocates a file and a file descriptor <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L325">(kernel/sysfile.c:325) </a>and then fills in the file <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L337-L342">(kernel/sysfile.c:337-</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sysfile.c#L337-L342">342)</a>. Note that no other process can access the partially initialized file since it is only in the current process’s table.</p>
<p>Chapter 7 examined the implementation of pipes before we even had a file system. The function sys_pipe connects that implementation to the file system by providing a way to create a pipe pair. Its argument is a pointer to space for two integers, where it will record the two new file descriptors. Then it allocates the pipe and installs the file descriptors.</p>
<h1 id="8-15-Real-world"><a href="#8-15-Real-world" class="headerlink" title="8.15     Real world"></a>8.15     Real world</h1><p>The buffer cache in a real-world operating system is significantly more complex than xv6’s, but it serves the same two purposes: caching and synchronizing access to the disk. Xv6’s buffer cache, like V6’s, uses a simple least recently used (LRU) eviction policy; there are many more complex policies that can be implemented, each good for some workloads and not as good for others. A more efficient LRU cache would eliminate the linked list, instead using a hash table for lookups and a heap for LRU evictions. Modern buffer caches are typically integrated with the virtual memory system to support memory-mapped files.</p>
<p>Xv6’s logging system is inefficient. A commit cannot occur concurrently with file-system sys- tem calls. The system logs entire blocks, even if only a few bytes in a block are changed. It performs synchronous log writes, a block at a time, each of which is likely to require an entire disk rotation time. Real logging systems address all of these problems.</p>
<p>Logging is not the only way to provide crash recovery. Early file systems used a scavenger during reboot (for example, the UNIX fsck program) to examine every file and directory and the block and inode free lists, looking for and resolving inconsistencies. Scavenging can take hours for large file systems, and there are situations where it is not possible to resolve inconsistencies in a way that causes the original system calls to be atomic. Recovery from a log is much faster and causes system calls to be atomic in the face of crashes.</p>
<p>Xv6 uses the same basic on-disk layout of inodes and directories as early UNIX; this scheme has been remarkably persistent over the years. BSD’s UFS/FFS and Linux’s ext2/ext3 use essen- tially the same data structures. The most inefficient part of the file system layout is the directory, which requires a linear scan over all the disk blocks during each lookup. This is reasonable when directories are only a few disk blocks, but is expensive for directories holding many files. Microsoft Windows’s NTFS, Mac OS X’s HFS, and Solaris’s ZFS, just to name a few, implement a direc- tory as an on-disk balanced tree of blocks. This is complicated but guarantees logarithmic-time directory lookups.</p>
<p>Xv6 is naive about disk failures: if a disk operation fails, xv6 panics. Whether this is reasonable depends on the hardware: if an operating systems sits atop special hardware that uses redundancy to mask disk failures, perhaps the operating system sees failures so infrequently that panicking is okay. On the other hand, operating systems using plain disks should expect failures and handle them more gracefully, so that the loss of a block in one file doesn’t affect the use of the rest of the file system.</p>
<p>Xv6 requires that the file system fit on one disk device and not change in size. As large databases and multimedia files drive storage requirements ever higher, operating systems are de-</p>
<p>veloping ways to eliminate the “one disk per file system” bottleneck. The basic approach is to combine many disks into a single logical disk. Hardware solutions such as RAID are still the most popular, but the current trend is moving toward implementing as much of this logic in software as possible. These software implementations typically allow rich functionality like growing or shrink- ing the logical device by adding or removing disks on the fly. Of course, a storage layer that can grow or shrink on the fly requires a file system that can do the same: the fixed-size array of inode blocks used by xv6 would not work well in such environments. Separating disk management from the file system may be the cleanest design, but the complex interface between the two has led some systems, like Sun’s ZFS, to combine them.</p>
<p>Xv6’s file system lacks many other features of modern file systems; for example, it lacks sup- port for snapshots and incremental backup.</p>
<p>Modern Unix systems allow many kinds of resources to be accessed with the same system calls as on-disk storage: named pipes, network connections, remotely-accessed network file systems, and monitoring and control interfaces such as /proc. Instead of xv6’s if statements in fileread and filewrite, these systems typically give each open file a table of function pointers, one per operation, and call the function pointer to invoke that inode’s implementation of the call. Network file systems and user-level file systems provide functions that turn those calls into network RPCs and wait for the response before returning.</p>
<h1 id="8-16-Exercises"><a href="#8-16-Exercises" class="headerlink" title="8.16     Exercises"></a>8.16     Exercises</h1><p>\1.   Why panic in balloc ? Can xv6 recover?</p>
<p>\2.   Why panic in ialloc ? Can xv6 recover?</p>
<p>\3.   Why doesn’t filealloc panic when it runs out of files? Why is this more common and therefore worth handling?</p>
<p>\4.             Suppose the file corresponding to ip gets unlinked by another process between sys_link</p>
<p>’s calls to iunlock(ip) and dirlink. Will the link be created correctly? Why or why not?</p>
<p>\5.   create makes four function calls (one to ialloc and three to dirlink) that it requires to succeed. If any doesn’t, create calls panic. Why is this acceptable? Why can’t any of those four calls fail?</p>
<p>\6.   sys_chdir calls iunlock(ip) before iput(cp-&gt;cwd), which might try to lock cp-&gt;cwd, yet postponing iunlock(ip) until after the iput would not cause deadlocks. Why not?</p>
<p>\7.             Implement the lseek system call. Supporting lseek will also require that you modify</p>
<p>filewrite to fill holes in the file with zero if lseek sets off beyond f-&gt;ip-&gt;size.</p>
<p>\8.   Add O_TRUNC and O_APPEND to open, so that &gt; and &gt;&gt; operators work in the shell.</p>
<p>\9.   Modify the file system to support symbolic links.</p>
<p>\10.   Modify the file system to support named pipes.</p>
<p>\11.   Modify the file and VM system to support memory-mapped files.</p>
<p><strong>Chapter 9 Concurrency revisited</strong></p>
<p>Simultaneously obtaining good parallel performance, correctness despite concurrency, and under- standable code is a big challenge in kernel design. Straightforward use of locks is the best path to correctness, but is not always possible. This chapter highlights examples in which xv6 is forced to use locks in an involved way, and examples where xv6 uses lock-like techniques but not locks.</p>
<h1 id="9-1-Locking-patterns"><a href="#9-1-Locking-patterns" class="headerlink" title="9.1     Locking patterns"></a>9.1     Locking patterns</h1><p>Cached items are often a challenge to lock. For example, the filesystem’s block cache <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L26">(kernel/bio.c:26)</a> stores copies of up to NBUF disk blocks. It’s vital that a given disk block have at most one copy in the cache; otherwise, different processes might make conflicting changes to different copies of what ought to be the same block. Each cached block is stored in a struct buf <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/buf.h#L1">(kernel/buf.h:1)</a>. A struct buf has a lock field which helps ensure that only one process uses a given disk block at a time. However, that lock is not enough: what if a block is not present in the cache at all, and two processes want to use it at the same time? There is no struct buf (since the block isn’t yet cached), and thus there is nothing to lock. Xv6 deals with this situation by associating an addi- tional lock (bcache.lock) with the set of identities of cached blocks. Code that needs to check if a block is cached (e.g., bget <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/bio.c#L59">(kernel/bio.c:59)</a>), or change the set of cached blocks, must hold bcache.lock; after that code has found the block and struct buf it needs, it can release bcache.lock and lock just the specific block. This is a common pattern: one lock for the set of items, plus one lock per item.</p>
<p>Ordinarily the same function that acquires a lock will release it. But a more precise way to view things is that a lock is acquired at the start of a sequence that must appear atomic, and released when that sequence ends. If the sequence starts and ends in different functions, or different threads, or on different CPUs, then the lock acquire and release must do the same. The function of the lock is to force other uses to wait, not to pin a piece of data to a particular agent. One example is the acquire in yield <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L515">(kernel/proc.c:515)</a>, which is released in the scheduler thread rather than in the acquiring process. Another example is the acquiresleep in ilock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L289">(kernel/fs.c:289)</a>; this code often sleeps while reading the disk; it may wake up on a different CPU, which means the lock may be acquired and released on different CPUs.</p>
<p>Freeing an object that is protected by a lock embedded in the object is a delicate business, since owning the lock is not enough to guarantee that freeing would be correct. The problem case arises when some other thread is waiting in acquire to use the object; freeing the object implicitly frees the embedded lock, which will cause the waiting thread to malfunction. One so- lution is to track how many references to the object exist, so that it is only freed when the last reference disappears. See pipeclose <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L59">(kernel/pipe.c:59)</a> for an example; pi-&gt;readopen and pi-&gt;writeopen track whether the pipe has file descriptors referring to it.</p>
<h1 id="9-2-Lock-like-patterns"><a href="#9-2-Lock-like-patterns" class="headerlink" title="9.2     Lock-like patterns"></a>9.2     Lock-like patterns</h1><p>In many places xv6 uses a reference count or a flag as a kind of soft lock to indicate that an object is allocated and should not be freed or re-used. A process’s p-&gt;state acts in this way, as do the reference counts in file, inode, and buf structures. While in each case a lock protects the flag or reference count, it is the latter that prevents the object from being prematurely freed.</p>
<p>The file system uses struct inode reference counts as a kind of shared lock that can be held by multiple processes, in order to avoid deadlocks that would occur if the code used ordinary locks. For example, the loop in namex <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fs.c#L626">(kernel/fs.c:626)</a> locks the directory named by each pathname component in turn. However, namex must release each lock at the end of the loop, since if it held multiple locks it could deadlock with itself if the pathname included a dot (e.g., a/./b). It might also deadlock with a concurrent lookup involving the directory and … As Chapter 8 explains, the solution is for the loop to carry the directory inode over to the next iteration with its reference count incremented, but not locked.</p>
<p>Some data items are protected by different mechanisms at different times, and may at times be protected from concurrent access implicitly by the structure of the xv6 code rather than by explicit locks. For example, when a physical page is free, it is protected by                                                       kmem.lock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L24">(ker-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/kalloc.c#L24">nel/kalloc.c:24)</a>. If the page is then allocated as a pipe <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/pipe.c#L23">(kernel/pipe.c:23)</a>, it is protected by a different lock (the embedded pi-&gt;lock). If the page is re-allocated for a new process’s user memory, it is not protected by a lock at all. Instead, the fact that the allocator won’t give that page to any other process (until it is freed) protects it from concurrent access. The ownership of a new process’s memory is complex: first the parent allocates and manipulates it in fork, then the child uses it, and (after the child exits) the parent again owns the memory and passes it to kfree. There are two lessons here: a data object may be protected from concurrency in different ways at different points in its lifetime, and the protection may take the form of implicit structure rather than explicit locks. A final lock-like example is the need to disable interrupts around calls to mycpu() <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L68">(ker-</a> <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L68">nel/proc.c:68)</a>. Disabling interrupts causes the calling code to be atomic with respect to timer in-</p>
<p>terrupts that could force a context switch, and thus move the process to a different CPU.</p>
<h1 id="9-3-No-locks-at-all"><a href="#9-3-No-locks-at-all" class="headerlink" title="9.3     No locks at all"></a>9.3     No locks at all</h1><p>There are a few places where xv6 shares mutable data with no locks at all. One is in the implemen- tation of spinlocks, although one could view the RISC-V atomic instructions as relying on locks</p>
<p>implemented in hardware. Another is the started variable in main.c <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/main.c#L7">(kernel/main.c:7)</a>, used to prevent other CPUs from running until CPU zero has finished initializing xv6; the volatile ensures that the compiler actually generates load and store instructions. A third are some uses of p-&gt;parent in proc.c <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L398">(kernel/proc.c:398) </a><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L306">(kernel/proc.c:306) </a>where proper locking could dead- lock, but it seems clear that no other process could be simultaneously modifying p-&gt;parent. A fourth example is p-&gt;killed, which is set while holding p-&gt;lock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c#L611">(kernel/proc.c:611)</a>, but checked without a holding lock <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c#L56">(kernel/trap.c:56)</a>.</p>
<p>Xv6 contains cases in which one CPU or thread writes some data, and another CPU or thread reads the data, but there is no specific lock dedicated to protecting that data. For example, in fork, the parent writes the child’s user memory pages, and the child (a different thread, perhaps on a different CPU) reads those pages; no lock explicitly protects those pages. This is not strictly a locking problem, since the child doesn’t start executing until after the parent has finished writing. It is a potential memory ordering problem (see Chapter 6), since without a memory barrier there’s no reason to expect one CPU to see another CPU’s writes. However, since the parent releases locks, and the child acquires locks as it starts up, the memory barriers in acquire and release ensure that the child’s CPU sees the parent’s writes.</p>
<h1 id="9-4-Parallelism"><a href="#9-4-Parallelism" class="headerlink" title="9.4     Parallelism"></a>9.4     Parallelism</h1><p>Locking is primarily about suppressing parallelism in the interests of correctness. Because perfor- mance is also important, kernel designers often have to think about how to use locks in a way that achieves both correctness and good parallelism. While xv6 is not systematically designed for high performance, it’s still worth considering which xv6 operations can execute in parallel, and which might conflict on locks.</p>
<p>Pipes in xv6 are an example of fairly good parallelism. Each pipe has its own lock, so that dif- ferent processes can read and write different pipes in parallel on different CPUs. For a given pipe, however, the writer and reader must wait for each other to release the lock; they can’t read/write the same pipe at the same time. It is also the case that a read from an empty pipe (or a write to a full pipe) must block, but this is not due to the locking scheme.</p>
<p>Context switching is a more complex example. Two kernel threads, each executing on its own CPU, can call yield, sched, and swtch at the same time, and the calls will execute in parallel. The threads each hold a lock, but they are different locks, so they don’t have to wait for each other. Once in scheduler, however, the two CPUs may conflict on locks while searching the table of processes for one that is RUNNABLE. That is, xv6 is likely to get a performance benefit from multiple CPUs during context switch, but perhaps not as much as it could.</p>
<p>Another example is concurrent calls to fork from different processes on different CPUs. The calls may have to wait for each other for pid_lock and kmem.lock, and for per-process locks needed to search the process table for an UNUSED process. On the other hand, the two forking processes can copy user memory pages and format page-table pages fully in parallel.</p>
<p>The locking scheme in each of the above examples sacrifices parallel performance in certain cases. In each case it’s possible to obtain more parallelism using a more elaborate design. Whether it’s worthwhile depends on details: how often the relevant operations are invoked, how long the</p>
<p>code spends with a contended lock held, how many CPUs might be running conflicting operations at the same time, whether other parts of the code are more restrictive bottlenecks. It can be difficult to guess whether a given locking scheme might cause performance problems, or whether a new design is significantly better, so measurement on realistic workloads is often required.</p>
<h1 id="9-5-Exercises"><a href="#9-5-Exercises" class="headerlink" title="9.5     Exercises"></a>9.5     Exercises</h1><p>\1.   Modify xv6’s pipe implementation to allow a read and a write to the same pipe to proceed in parallel on different cores.</p>
<p>\2.   Modify xv6’s scheduler() to reduce lock contention when different cores are looking for runnable processes at the same time.</p>
<p>\3.   Eliminate some of the serialization in xv6’s fork().</p>
<p><strong>Chapter 10 Summary</strong></p>
<p>This text introduced the main ideas in operating systems by studying one operating system, xv6, line by line. Some code lines embody the essence of the main ideas (e.g., context switching, user/k- ernel boundary, locks, etc.) and each line is important; other code lines provide an illustration of how to implement a particular operating system idea and could easily be done in different ways (e.g., a better algorithm for scheduling, better on-disk data structures to represent files, better log- ging to allow for concurrent transactions, etc.). All the ideas were illustrated in the context of one particular, very successful system call interface, the Unix interface, but those ideas carry over to the design of other operating systems.</p>
<p><strong>Bibliography</strong></p>
<p>[1]   The RISC-V instruction set manual: privileged architecture. <a target="_blank" rel="noopener" href="https://riscv.org/specifications/privileged-isa/">https://riscv.org/</a> <a target="_blank" rel="noopener" href="https://riscv.org/specifications/privileged-isa/">specifications/privileged-isa/</a>, 2019.</p>
<p>[2]   The  RISC-V  instruction  set  manual:  user-level  ISA. <a target="_blank" rel="noopener" href="https://riscv.org/specifications/isa-spec-pdf/">https://riscv.org/</a> <a target="_blank" rel="noopener" href="https://riscv.org/specifications/isa-spec-pdf/">specifications/isa-spec-pdf/</a>, 2019.</p>
<p>[3]   Hans-J Boehm. Threads cannot be implemented as a library. <em>ACM PLDI Conference</em>, 2005.</p>
<p>[4]   Edsger Dijkstra. Cooperating sequential processes. <a target="_blank" rel="noopener" href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html">https://www.cs.utexas.edu/</a> <a target="_blank" rel="noopener" href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html">users/EWD/transcriptions/EWD01xx/EWD123.html</a>, 1965.</p>
<p>[5]   Maurice Herlihy and Nir Shavit. <em>The Art of Multiprocessor Programming, Revised Reprint</em>. 2012.</p>
<p>[6]   Brian W. Kernighan. <em>The C Programming Language</em>. Prentice Hall Professional Technical Reference, 2nd edition, 1988.</p>
<p>[7]   Donald Knuth. <em>Fundamental Algorithms. The Art of Computer Programming. (Second ed.)</em>, volume 1. 1997.</p>
<p>[8]   L Lamport. A new solution of dijkstra’s concurrent programming problem. <em>Communications of the ACM</em>, 1974.</p>
<p>[9]   John Lions. <em>Commentary on UNIX 6th Edition</em>. Peer to Peer Communications, 2000.</p>
<p>[10]   Paul E. Mckenney, Silas Boyd-wickizer, and Jonathan Walpole. RCU usage in the linux kernel: One decade later, 2013.</p>
<p>[11]   Martin Michael and Daniel Durich. The NS16550A: UART design and application consid- erations. <a target="_blank" rel="noopener" href="http://bitsavers.trailing-edge.com/components/national/_appNotes/AN-0491.pdf">http://bitsavers.trailing-edge.com/components/national/</a></p>
<p><a target="_blank" rel="noopener" href="http://bitsavers.trailing-edge.com/components/national/_appNotes/AN-0491.pdf">_appNotes/AN-0491.pdf</a>, 1987.</p>
<p>[12]   David Patterson and Andrew Waterman. <em>The RISC-V Reader: an open architecture Atlas</em>. Strawberry Canyon, 2017.</p>
<p>[13]   Dave Presotto, Rob Pike, Ken Thompson, and Howard Trickey. Plan 9, a distributed system. In <em>In Proceedings of the Spring 1991 EurOpen Conference</em>, pages 43–50, 1991.</p>
<p>[14]   Dennis M. Ritchie and Ken Thompson. The UNIX time-sharing system. <em>Commun. ACM</em>, 17(7):365–375, July 1974.</p>
<p><strong>Index</strong></p>
<p>., 92, 94</p>
<p>.., 92, 94</p>
<p>/init, 28, 37</p>
<p>_entry, 27</p>
<p>absorption, 86</p>
<p>acquire, 59, 62</p>
<p>address space, 25</p>
<p>argc, 37</p>
<p>argv, 37</p>
<p>atomic, 59</p>
<p>balloc, 87, 89</p>
<p>batching, 85</p>
<p>bcache.head, 83</p>
<p>begin_op, 86</p>
<p>bfree, 87</p>
<p>bget, 83</p>
<p>binit, 83</p>
<p>bmap, 91</p>
<p>bottom half, 49</p>
<p>bread, 82, 84</p>
<p>brelse, 82, 84</p>
<p>BSIZE, 91</p>
<p>buf, 82</p>
<p>busy waiting, 72</p>
<p>bwrite, 82, 84, 86</p>
<p>chan, 72, 74</p>
<p>child process, 10</p>
<p>commit, 84</p>
<p>concurrency, 55</p>
<p>concurrency control, 55</p>
<p>condition lock, 73</p>
<p>conditional synchronization, 71</p>
<p>conflict, 58</p>
<p>contention, 58</p>
<p>contexts, 68</p>
<p>convoys, 78</p>
<p>copy-on-write (COW) fork, 46</p>
<p>copyinstr, 45</p>
<p>copyout, 37</p>
<p>coroutines, 69</p>
<p>CPU, 9</p>
<p>cpu-&gt;scheduler, 68, 69</p>
<p>crash recovery, 81</p>
<p>create, 94</p>
<p>critical section, 58</p>
<p>current directory, 17</p>
<p>deadlock, 60</p>
<p>direct blocks, 91</p>
<p>direct memory access (DMA), 52</p>
<p>dirlink, 92</p>
<p>dirlookup, 91, 92, 94</p>
<p>DIRSIZ, 91</p>
<p>disk, 83</p>
<p>driver, 49</p>
<p>dup, 93</p>
<p>ecall, 23, 26</p>
<p>ELF format, 37</p>
<p>ELF_MAGIC, 37</p>
<p>end_op, 86</p>
<p>exception, 41</p>
<p>exec, 12, 14, 27, 37, 44</p>
<p>exit, 11, 70, 76</p>
<p>file descriptor, 13</p>
<p>filealloc, 93</p>
<p>fileclose, 93</p>
<p>filedup, 93</p>
<p>fileread, 93, 96</p>
<p>filestat, 93</p>
<p>filewrite, 87, 93, 96</p>
<p>fork, 10, 12, 14, 93</p>
<p>forkret, 69</p>
<p>freerange, 35</p>
<p>fsck, 95</p>
<p>fsinit, 86</p>
<p>ftable, 93</p>
<p>getcmd, 12</p>
<p>group commit, 85</p>
<p>guard page, 33</p>
<p>hartid, 70</p>
<p>I/O, 13</p>
<p>I/O concurrency, 51</p>
<p>I/O redirection, 14</p>
<p>ialloc, 89, 94</p>
<p>iget, 88, 89, 92</p>
<p>ilock, 88, 89, 92</p>
<p>indirect block, 91</p>
<p>initcode.S, 27, 44</p>
<p>initlog, 86</p>
<p>inode, 18, 82, 87</p>
<p>install_trans, 86</p>
<p>interface design, 9</p>
<p>interrupt, 41</p>
<p>iput, 88, 89</p>
<p>isolation, 21</p>
<p>itrunc, 89, 91</p>
<p>iunlock, 89</p>
<p>kalloc, 35</p>
<p>kernel, 9, 23</p>
<p>kernel space, 9, 23</p>
<p>kfree, 35</p>
<p>kinit, 35</p>
<p>kvminit, 33</p>
<p>kvminithart, 34</p>
<p>kvmmap, 33</p>
<p>lazy allocation, 47</p>
<p>links, 18</p>
<p>loadseg, 37</p>
<p>lock, 55</p>
<p>log, 84</p>
<p>log_write, 86</p>
<p>lost wake-up, 72</p>
<p>machine mode, 23</p>
<p>main, 33–35, 83</p>
<p>malloc, 13</p>
<p>mappages, 33</p>
<p>memory barrier, 63</p>
<p>memory model, 63</p>
<p>memory-mapped, 31, 49</p>
<p>metadata, 18</p>
<p>microkernel, 24</p>
<p>mkdev, 94</p>
<p>mkdir, 94</p>
<p>mkfs, 82</p>
<p>monolithic kernel, 21, 23</p>
<p>multi-core, 21</p>
<p>multiplexing, 67</p>
<p>multiprocessor, 21</p>
<p>mutual exclusion, 57</p>
<p>mycpu, 70</p>
<p>myproc, 71</p>
<p>namei, 37, 94</p>
<p>nameiparent, 92, 94</p>
<p>namex, 92</p>
<p>NBUF, 83</p>
<p>NDIRECT, 90, 91</p>
<p>NINDIRECT, 91</p>
<p>O_CREATE, 94</p>
<p>open, 93, 94</p>
<p>p-&gt;context, 70</p>
<p>p-&gt;killed, 77, 101</p>
<p>p-&gt;kstack, 26</p>
<p>p-&gt;lock, 69, 70, 74</p>
<p>p-&gt;pagetable, 26, 27</p>
<p>p-&gt;state, 27</p>
<p>p-&gt;xxx, 26</p>
<p>page, 29</p>
<p>page table entries (PTEs), 29 page-fault exception, 30, 47 paging from disk, 47</p>
<p>parent process, 10</p>
<p>path, 17</p>
<p>persistence, 81</p>
<p>PGROUNDUP, 35</p>
<p>physical address, 25</p>
<p>PHYSTOP, 33, 34</p>
<p>PID, 10</p>
<p>pipe, 15</p>
<p>piperead, 75</p>
<p>pipewrite, 75</p>
<p>polling, 52, 72</p>
<p>pop_off, 62</p>
<p>printf, 12</p>
<p>priority inversion, 78</p>
<p>privileged instructions, 23</p>
<p>proc_pagetable, 37</p>
<p>process, 9, 24</p>
<p>procinit, 34</p>
<p>programmed I/O, 52</p>
<p>PTE_R, 30</p>
<p>PTE_U, 30</p>
<p>PTE_V, 30</p>
<p>PTE_W, 30</p>
<p>PTE_X, 30</p>
<p>push_off, 62</p>
<p>race condition, 57</p>
<p>read, 93</p>
<p>readi, 37, 91</p>
<p>recover_from_log, 86</p>
<p>release, 59, 62</p>
<p>root, 17</p>
<p>round robin, 77</p>
<p>RUNNABLE, 70, 74, 76</p>
<p>satp, 30</p>
<p>sbrk, 13</p>
<p>scause, 42</p>
<p>sched, 68, 69, 74</p>
<p>scheduler, 69, 70</p>
<p>semaphore, 71</p>
<p>sepc, 42</p>
<p>sequence coordination, 71</p>
<p>serializing, 58</p>
<p>sfence.vma, 34</p>
<p>shell, 10</p>
<p>signal, 78</p>
<p>skipelem, 92</p>
<p>sleep, 72–74</p>
<p>sleep-locks, 63</p>
<p>SLEEPING, 74</p>
<p>sret, 27</p>
<p>sscratch, 42</p>
<p>sstatus, 42</p>
<p>stat, 91, 93</p>
<p>stati, 91, 93</p>
<p>struct context, 68</p>
<p>struct cpu, 70</p>
<p>struct dinode, 87, 90</p>
<p>struct dirent, 91</p>
<p>struct elfhdr, 37</p>
<p>struct file, 93</p>
<p>struct inode, 88</p>
<p>struct pipe, 75</p>
<p>struct proc, 26</p>
<p>struct run, 34</p>
<p>struct spinlock, 58</p>
<p>stval, 47</p>
<p>stvec, 42</p>
<p>superblock, 82</p>
<p>supervisor mode, 23</p>
<p>swtch, 68–70</p>
<p>SYS_exec, 45</p>
<p>sys_link, 94</p>
<p>sys_mkdir, 94</p>
<p>sys_mknod, 94</p>
<p>sys_open, 94</p>
<p>sys_pipe, 95</p>
<p>sys_sleep, 62</p>
<p>sys_unlink, 94</p>
<p>syscall, 45</p>
<p>system call, 9</p>
<p>T_DEV, 91</p>
<p>T_DIR, 91</p>
<p>T_FILE, 94</p>
<p>thread, 26</p>
<p>thundering herd, 78</p>
<p>ticks, 62</p>
<p>tickslock, 62</p>
<p>time-share, 10, 21</p>
<p>top half, 49</p>
<p>TRAMPOLINE, 43</p>
<p>trampoline, 26, 43</p>
<p>transaction, 81</p>
<p>Translation Look-aside Buffer (TLB), 34 transmit complete, 50</p>
<p>trap, 41</p>
<p>trapframe, 26</p>
<p>type cast, 35</p>
<p>UART, 49</p>
<p>unlink, 85</p>
<p>user memory, 25</p>
<p>user mode, 23</p>
<p>user space, 9, 23</p>
<p>usertrap, 68</p>
<p>ustack, 37</p>
<p>uvmalloc, 37</p>
<p>valid, 83</p>
<p>virtio_disk_rw, 83, 84</p>
<p>virtual address, 25</p>
<p>wait, 11, 12, 70, 76</p>
<p>wait channel, 72</p>
<p>wakeup, 61, 72, 74</p>
<p>walk, 33</p>
<p>walkaddr, 37</p>
<p>write, 85, 93</p>
<p>write-through, 88</p>
<p>writei, 87, 91</p>
<p>yield, 68–70</p>
<p>ZOMBIE, 76</p>

    </div>

    
    
    
	
	 

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/08/696div2-C-Array-Destruction/" rel="prev" title="C. Array Destruction">
      <i class="fa fa-chevron-left"></i> C. Array Destruction
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/09/695div2-B-Hills-And-Valleys/" rel="next" title="695div2B. Hills And Valleys">
      695div2B. Hills And Valleys <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#xv6-a-simple-Unix-like-teaching-operating-system"><span class="nav-number">1.</span> <span class="nav-text">xv6: a simple, Unix-like teaching operating system</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Foreword-and-acknowledgments"><span class="nav-number">1.1.</span> <span class="nav-text">Foreword and acknowledgments</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-1-Operating-system-interfaces"><span class="nav-number">2.</span> <span class="nav-text">**Chapter 1 **  Operating system interfaces</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Processes-and-memory"><span class="nav-number">2.1.</span> <span class="nav-text">1.1     Processes and memory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-I-O-and-File-descriptors"><span class="nav-number">2.2.</span> <span class="nav-text">1.2     I&#x2F;O and File descriptors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Pipes"><span class="nav-number">2.3.</span> <span class="nav-text">1.3     Pipes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-File-system"><span class="nav-number">2.4.</span> <span class="nav-text">1.4     File system</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-Real-world"><span class="nav-number">2.5.</span> <span class="nav-text">1.5     Real world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-Exercises"><span class="nav-number">2.6.</span> <span class="nav-text">1.6     Exercises</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-2-Operating-system-organization"><span class="nav-number">3.</span> <span class="nav-text">Chapter 2  Operating system organization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Abstracting-physical-resources"><span class="nav-number">3.1.</span> <span class="nav-text">2.1     Abstracting physical resources</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Code-xv6-organization"><span class="nav-number">3.2.</span> <span class="nav-text">2.4     Code: xv6 organization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Process-overview"><span class="nav-number">3.3.</span> <span class="nav-text">2.5     Process overview</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File"><span class="nav-number">3.3.0.1.</span> <span class="nav-text">File</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-3-Code-Calling-system-calls"><span class="nav-number">4.</span> <span class="nav-text">4.3     Code: Calling system calls</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-4-Code-System-call-arguments"><span class="nav-number">5.</span> <span class="nav-text">4.4     Code: System call arguments</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-5-Traps-from-kernel-space"><span class="nav-number">6.</span> <span class="nav-text">4.5     Traps from kernel space</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-6-Page-fault-exceptions"><span class="nav-number">7.</span> <span class="nav-text">4.6     Page-fault exceptions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-7-Real-world"><span class="nav-number">8.</span> <span class="nav-text">4.7     Real world</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-8-Exercises"><span class="nav-number">9.</span> <span class="nav-text">4.8     Exercises</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-1-Code-Console-input"><span class="nav-number">10.</span> <span class="nav-text">5.1     Code: Console input</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-2-Code-Console-output"><span class="nav-number">11.</span> <span class="nav-text">5.2     Code: Console output</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-3-Concurrency-in-drivers"><span class="nav-number">12.</span> <span class="nav-text">5.3     Concurrency in drivers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-4-Timer-interrupts"><span class="nav-number">13.</span> <span class="nav-text">5.4     Timer interrupts</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-5-Real-world"><span class="nav-number">14.</span> <span class="nav-text">5.5     Real world</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-6-Exercises"><span class="nav-number">15.</span> <span class="nav-text">5.6     Exercises</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory"><span class="nav-number">15.1.</span> <span class="nav-text">Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-CPU"><span class="nav-number">15.2.</span> <span class="nav-text">CPU          CPU</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-1-Race-conditions"><span class="nav-number">16.</span> <span class="nav-text">6.1     Race conditions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-2-Code-Locks"><span class="nav-number">17.</span> <span class="nav-text">6.2     Code: Locks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-3-Code-Using-locks"><span class="nav-number">18.</span> <span class="nav-text">6.3     Code: Using locks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-4-Deadlock-and-lock-ordering"><span class="nav-number">19.</span> <span class="nav-text">6.4     Deadlock and lock ordering</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock-Description"><span class="nav-number">19.0.0.1.</span> <span class="nav-text">      Lock           Description</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-5-Locks-and-interrupt-handlers"><span class="nav-number">20.</span> <span class="nav-text">6.5     Locks and interrupt handlers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-6-Instruction-and-memory-ordering"><span class="nav-number">21.</span> <span class="nav-text">6.6     Instruction and memory ordering</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-7-Sleep-locks"><span class="nav-number">22.</span> <span class="nav-text">6.7     Sleep locks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-8-Real-world"><span class="nav-number">23.</span> <span class="nav-text">6.8     Real world</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-9-Exercises"><span class="nav-number">24.</span> <span class="nav-text">6.9     Exercises</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-1-Multiplexing"><span class="nav-number">25.</span> <span class="nav-text">7.1     Multiplexing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-2-Code-Context-switching"><span class="nav-number">26.</span> <span class="nav-text">7.2     Code: Context switching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-3-Code-Scheduling"><span class="nav-number">27.</span> <span class="nav-text">7.3     Code: Scheduling</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-4-Code-mycpu-and-myproc"><span class="nav-number">28.</span> <span class="nav-text">7.4     Code: mycpu and myproc</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-5-Sleep-and-wakeup"><span class="nav-number">29.</span> <span class="nav-text">7.5     Sleep and wakeup</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-6-Code-Sleep-and-wakeup"><span class="nav-number">30.</span> <span class="nav-text">7.6     Code: Sleep and wakeup</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-7-Code-Pipes"><span class="nav-number">31.</span> <span class="nav-text">7.7     Code: Pipes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-8-Code-Wait-exit-and-kill"><span class="nav-number">32.</span> <span class="nav-text">7.8     Code: Wait, exit, and kill</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-9-Real-world"><span class="nav-number">33.</span> <span class="nav-text">7.9     Real world</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-10-Exercises"><span class="nav-number">34.</span> <span class="nav-text">7.10     Exercises</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-1-Overview"><span class="nav-number">35.</span> <span class="nav-text">8.1     Overview</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-2-Buffer-cache-layer"><span class="nav-number">36.</span> <span class="nav-text">8.2     Buffer cache layer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-3-Code-Buffer-cache"><span class="nav-number">37.</span> <span class="nav-text">8.3     Code: Buffer cache</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-4-Logging-layer"><span class="nav-number">38.</span> <span class="nav-text">8.4     Logging layer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-5-Log-design"><span class="nav-number">39.</span> <span class="nav-text">8.5     Log design</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-6-Code-logging"><span class="nav-number">40.</span> <span class="nav-text">8.6     Code: logging</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-7-Code-Block-allocator"><span class="nav-number">41.</span> <span class="nav-text">8.7     Code: Block allocator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-8-Inode-layer"><span class="nav-number">42.</span> <span class="nav-text">8.8     Inode layer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-9-Code-Inodes"><span class="nav-number">43.</span> <span class="nav-text">8.9     Code: Inodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-10-Code-Inode-content"><span class="nav-number">44.</span> <span class="nav-text">8.10     Code: Inode content</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-11-Code-directory-layer"><span class="nav-number">45.</span> <span class="nav-text">8.11     Code: directory layer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-12-Code-Path-names"><span class="nav-number">46.</span> <span class="nav-text">8.12     Code: Path names</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-13-File-descriptor-layer"><span class="nav-number">47.</span> <span class="nav-text">8.13     File descriptor layer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-14-Code-System-calls"><span class="nav-number">48.</span> <span class="nav-text">8.14     Code: System calls</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-15-Real-world"><span class="nav-number">49.</span> <span class="nav-text">8.15     Real world</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-16-Exercises"><span class="nav-number">50.</span> <span class="nav-text">8.16     Exercises</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-1-Locking-patterns"><span class="nav-number">51.</span> <span class="nav-text">9.1     Locking patterns</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-2-Lock-like-patterns"><span class="nav-number">52.</span> <span class="nav-text">9.2     Lock-like patterns</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-3-No-locks-at-all"><span class="nav-number">53.</span> <span class="nav-text">9.3     No locks at all</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-4-Parallelism"><span class="nav-number">54.</span> <span class="nav-text">9.4     Parallelism</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-5-Exercises"><span class="nav-number">55.</span> <span class="nav-text">9.5     Exercises</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Nnnuus"
      src="https://i.loli.net/2021/03/13/nZa6FtkdxThVQoS.jpg">
  <p class="site-author-name" itemprop="name">Nnnuus</p>
  <div class="site-description" itemprop="description">比过程更重要的是结果</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-03 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nnnuus</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
